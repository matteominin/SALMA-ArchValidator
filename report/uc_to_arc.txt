[{uc_id=UC-1, implemented_by_components=[User Interface (UI), controllers, services, UserDao, UserDaoImpl, DBManager, Database Production (PostgreSQL), JPA (Jakarta Persistence API), Hibernate (hibernate-core), app_user, model], status=Covered, rationale=UI provides the registration/login screens; controllers handle input and session flows; services implement authentication/business rules; UserDao/UserDaoImpl persist and retrieve user records; DBManager and the database/JPA/Hibernate manage storage and transactions; app_user and model define user data structure.}, {uc_id=UC-2, implemented_by_components=[User Interface (UI), controllers, services, Transaction, TransactionItem, TransactionDao, UserDao, DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL)], status=Covered, rationale=UI lets customers choose recharge method/amount; controllers and services orchestrate the recharge flow; Transaction/TransactionItem model the recharge records; TransactionDao and UserDao persist balance changes; DBManager/JPA/Hibernate and the database ensure durable storage and transactional consistency.}, {uc_id=UC-3, implemented_by_components=[User Interface (UI), controllers, services, ConnectionDao, ConcreteVendingMachine, Inventory, item, Transaction, TransactionDao, Mapper Classes (TaskMapper, ConnectionMapper, InventoryMapper, TransactionMapper), DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL)], status=Covered, rationale=UI provides the purchase and QR scan interface; controllers/services manage the purchase flow and wallet deduction; ConnectionDao/ConnectionMapper track the machine connection; ConcreteVendingMachine, Inventory and item represent machine state and product availability; Transaction/TransactionDao record the sale; mappers and DB/JPA/Hibernate persist state.}, {uc_id=UC-4, implemented_by_components=[User Interface (UI), controllers, services, VendingMachineDao, ItemDao, TransactionDao, Mapper Classes (TaskMapper, ConnectionMapper, InventoryMapper, TransactionMapper), DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL), admin], status=Covered, rationale=Admin UI exposes configuration and reporting screens; controllers/services implement admin operations; VendingMachineDao and ItemDao manage machine and price data; TransactionDao plus mapper classes produce sales reports and analytics; DB/JPA/Hibernate persist configurations and metrics; admin model represents the actor.}, {uc_id=UC-5, implemented_by_components=[User Interface (UI), controllers, services, UserDao, VendingMachineDao, ItemDao, TaskDao, UserDaoImpl, DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL)], status=Covered, rationale=UI and controllers provide CRUD interfaces; services enforce business rules; UserDao, VendingMachineDao, ItemDao and TaskDao define persistence contracts for users, distributors and items; UserDaoImpl contains concrete persistence logic; DB/JPA/Hibernate store and manage entities.}, {uc_id=UC-6, implemented_by_components=[controllers, services, MaintenanceDao, TaskDao, ConcreteVendingMachine, Inventory, item, MachineStatus, Mapper Classes (TaskMapper, ConnectionMapper, InventoryMapper, TransactionMapper), DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL), worker], status=Covered, rationale=Controllers/services deliver maintenance notifications and workflows; MaintenanceDao and TaskDao track maintenance tasks and status; ConcreteVendingMachine, Inventory and item expose stock and malfunction state; MachineStatus models operational condition; mappers and DB/JPA/Hibernate persist reports; worker represents the actor performing tasks.}, {uc_id=UC-7, implemented_by_components=[User Interface (UI), controllers, services, app_user, admin, worker, customer, model, UserDao, DBManager, Database Production (PostgreSQL), JPA (Jakarta Persistence API)], status=Covered, rationale=UI, controllers and services enable interactions for different roles; role models (app_user, admin, worker, customer) define role-specific behavior; UserDao and persistence layers store role data and permissions; DB/JPA provide backing storage.}, {uc_id=UC-8, implemented_by_components=[User Interface (UI), controllers, services, UserDao, UserDaoImpl, DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL), model], status=Covered, rationale=Login UI captures credentials; controllers/services validate them and create sessions; UserDao/UserDaoImpl retrieve credentials; DBManager/JPA/Hibernate and the database persist authentication data; model defines user credential fields.}, {uc_id=UC-9, implemented_by_components=[User Interface (UI), controllers, services, customer, ConcreteVendingMachine, Inventory, TransactionDao, ItemDao, DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL)], status=Covered, rationale=General customer-facing use cases are enabled by UI, controllers and services; customer model represents the actor; ConcreteVendingMachine, Inventory, ItemDao and TransactionDao support browsing and purchases; persistence stack stores interactions.}, {uc_id=UC-10, implemented_by_components=[User Interface (UI), controllers, services, Transaction, TransactionDao, Inventory, item, ConcreteVendingMachine, VendingMachineDao, ConnectionDao, DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL)], status=Covered, rationale=UI/controller/service manage catalog selection and purchase; Inventory, item and ConcreteVendingMachine represent availability; Transaction and TransactionDao record the sale and balance deduction; VendingMachineDao/ConnectionDao manage machine association; persistence layers ensure state and consistency.}, {uc_id=UC-11, implemented_by_components=[User Interface (UI), controllers, services, ConnectionDao, Mapper Classes (TaskMapper, ConnectionMapper, InventoryMapper, TransactionMapper), ConcreteVendingMachine, Inventory, DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL)], status=Covered, rationale=UI supports QR scanning; controllers/services resolve and link the machine; ConnectionDao and ConnectionMapper persist the active connection; ConcreteVendingMachine and Inventory provide the inventory interface; persistence stack stores connection records.}, {uc_id=UC-12, implemented_by_components=[User Interface (UI), controllers, services, Transaction, TransactionDao, UserDao, DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL)], status=Covered, rationale=Personal page UI and controllers let customer select payment method/amount; services coordinate payment verification and wallet update; Transaction/TransactionDao record the recharge; UserDao updates wallet balance; persistence layers ensure atomicity and durability.}, {uc_id=UC-13, implemented_by_components=[User Interface (UI), controllers, services, TaskDao, TaskDaoImpl, Mapper Classes (TaskMapper, ConnectionMapper, InventoryMapper, TransactionMapper), DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL), worker], status=Covered, rationale=UI provides the technician dashboard; controllers/services handle the 'mark complete' action; TaskDao/TaskDaoImpl and TaskMapper persist the task state and logs; DB/JPA/Hibernate store task history; worker is the actor performing the action.}, {uc_id=UC-14, implemented_by_components=[User Interface (UI), controllers, services, TransactionDao, Mapper Classes (TaskMapper, ConnectionMapper, InventoryMapper, TransactionMapper), DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL), admin], status=Covered, rationale=Analytics UI and controllers request aggregated data; services query TransactionDao and other DAOs; mapper classes transform domain data for reporting; DB/JPA/Hibernate provide the persisted data; admin consumes analytics.}, {uc_id=UC-15, implemented_by_components=[User Interface (UI), controllers, services, VendingMachineDao, ConcreteVendingMachine, Builder, Inventory, DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL), admin], status=Covered, rationale=Creation UI and controllers capture machine data; services validate input; Builder constructs ConcreteVendingMachine instances; VendingMachineDao and Inventory persist the new machine and its inventory; DB/JPA/Hibernate store the entity; admin is the actor.}, {uc_id=UC-16, implemented_by_components=[User Interface (UI), Mockups, controllers, services, model], status=Covered, rationale=User navigation is realized by the UI and guided by Mockups; controllers and services handle screen transitions and business logic; model provides data for screens.}, {uc_id=UC-17, implemented_by_components=[controllers, services, ConnectionDao, ConnectionMapper, ConcreteVendingMachine, DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL)], status=Covered, rationale=Controllers/services initiate and track connections; ConnectionDao and ConnectionMapper store user_id, machine_id and timestamps; ConcreteVendingMachine is the target of the connection; DB/JPA/Hibernate persist the tracking records.}, {uc_id=UC-18, implemented_by_components=[controllers, services, MaintenanceDao, TaskDao, ConcreteVendingMachine, Inventory, MachineStatus, Mapper Classes (TaskMapper, ConnectionMapper, InventoryMapper, TransactionMapper), DBManager, JPA (Jakarta Persistence API), Hibernate (hibernate-core), Database Production (PostgreSQL), Technician, admin], status=Partially Covered, rationale=Controllers and services enable remote maintenance flows; MaintenanceDao and TaskDao track actions; ConcreteVendingMachine, Inventory and MachineStatus model stuck/unlocked products; mappers and persistence layers store changes. External device-level unlocks or hardware interfaces are not explicitly defined in the architecture, so implementation is partial.}]