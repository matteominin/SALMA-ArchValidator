{
  "1": "Universit`a degli Studi di Firenze\nDipartimento di Ingegneria dell’Informazione\nLEARN - IT\nAutore:\nLorenzo Ciabatti\nN° Matricola:\n6292744\nCorso principale:\nIngegneria del Software\nDocente corso:\nEnrico Vicario\n",
  "2": "Lorenzo Ciabatti\nIngegneria del Software\nContents\n1\nIntroduzione\n2\n1.1\nStatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2\n1.2\nTecnologie e Strumenti Utilizzati . . . . . . . . . . . . . . . . . . . . . . . . .\n2\n2\nProgettazione\n4\n2.1\nUse Case Diagram\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n4\n2.2\nUse case templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n5\n2.3\nMockup dell’interfaccia utente . . . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n3\nUML e Struttura\n11\n3.1\nPackage Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n11\n3.2\nClass Diagram\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n11\n3.2.1\nBusiness Logic\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n11\n3.2.1.1\nAdmin\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n12\n3.2.1.2\nTrainerController\n. . . . . . . . . . . . . . . . . . . . . . . .\n12\n3.2.1.3\nCompanyController . . . . . . . . . . . . . . . . . . . . . . .\n13\n3.2.1.4\nNotifier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13\n3.2.2\nDomain Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13\n3.2.2.1\nSubscription\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n14\n3.2.2.2\nFeeStrategy, SingleEmployeeFee e MultipleEmployeeFee . . .\n14\n3.2.2.3\nEmployee . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14\n3.2.2.4\nCompany . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14\n3.2.2.5\nTrainer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14\n3.2.2.6\nWorkshift . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14\n3.2.2.7\nMaterial, Slide e Video\n. . . . . . . . . . . . . . . . . . . . .\n14\n3.2.2.8\nCourse\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n15\n3.2.2.9\nFocusCourse . . . . . . . . . . . . . . . . . . . . . . . . . . .\n15\n3.2.3\nObject-Relational Mapping (ORM) . . . . . . . . . . . . . . . . . . . .\n15\n3.2.3.1\nConnectionManager . . . . . . . . . . . . . . . . . . . . . . .\n15\n3.2.3.2\nSubscriptionDAO\n. . . . . . . . . . . . . . . . . . . . . . . .\n16\n3.2.3.3\nWorkshiftDAO . . . . . . . . . . . . . . . . . . . . . . . . . .\n16\n3.2.3.4\nCompanyDAO . . . . . . . . . . . . . . . . . . . . . . . . . .\n16\n3.2.3.5\nTrainerDAO\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n16\n3.2.3.6\nMaterialDAO . . . . . . . . . . . . . . . . . . . . . . . . . . .\n17\n3.2.3.7\nEmployeeDAO . . . . . . . . . . . . . . . . . . . . . . . . . .\n17\n3.2.3.8\nCourseDAO\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n18\n3.3\nDatabase\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n18\n4\nTesting\n20\n4.1\nTest package Controllers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n20\n4.1.1\nAdminTest\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n20\n4.1.2\nCompanyControllerTest . . . . . . . . . . . . . . . . . . . . . . . . . .\n21\n4.1.3\nTrainerControllerTest\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n21\n4.2\nTest package ORM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n22\n4.2.1\nTrainerDAOTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n22\n4.3\nRisultati dei test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n24\n1\n",
  "3": "Lorenzo Ciabatti\nIngegneria del Software\n1\nIntroduzione\n1.1\nStatement\nIl presente programma `e progettato per gestire un centro di formazione su tematiche legate al\nsettore IT, offrendo funzionalit`a avanzate per l’organizzazione e la gestione delle iscrizioni,\nnonch´e per la visualizzazione dei dati anagrafici degli impiegati partecipanti. Le aziende\npossono consultare il calendario dei corsi di formazione previsti e accedere ai contenuti\nmultimediali pubblicati dai formatori.\n• Amministratore: `e responsabile della creazione, modifica ed eventuale eliminazione\ndei corsi di formazione, assegnando a ciascuno una data, un orario e una breve de-\nscrizione. Inoltre, gestisce la pianificazione dei turni dei formatori e invia promemoria\nalle aziende in merito al pagamento delle quote di iscrizione. Al termine della creazione\no modifica di un corso, il sistema invia automaticamente una notifica sia alle aziende\nsia ai formatori, garantendo una comunicazione puntuale. In modo analogo, ogni volta\nche i turni vengono assegnati o modificati, i formatori coinvolti ricevono una notifica.\n• Formatori: hanno accesso alla visualizzazione dei propri turni di lavoro e all’elenco\ncompleto degli impiegati iscritti. Per ciascun impiegato `e possibile consultare le in-\nformazioni anagrafiche e altri dati utili, come ruolo, et`a e azienda di appartenenza. I\nformatori possono inoltre caricare, e se necessario rimuovere, materiali didattici (slide\ne video) relativi ai corsi.\n• Aziende: si occupano dell’iscrizione dei propri impiegati ai corsi di formazione, for-\nnendo i dati richiesti. Possono consultare in qualsiasi momento il calendario dei corsi\npianificati e il materiale multimediale caricato dai formatori. Il pagamento della quota\ndi iscrizione pu`o essere effettuato anche successivamente. `E prevista una tariffa intera\nper ciascun impiegato, con una riduzione applicata in caso di iscrizione multipla da\nparte della stessa azienda.\n1.2\nTecnologie e Strumenti Utilizzati\nPer lo sviluppo del presente progetto sono stati adottati strumenti e tecnologie, selezionati\nper garantire efficienza, scalabilit`a e qualit`a del software.\n• Ambiente di sviluppo: Intellij IDEA, integrato con GitHub Copilot, `e stato utiliz-\nzato come IDE principale per scrivere, completare e ottimizzare il codice Java, miglio-\nrando la produttivit`a grazie all’automazione intelligente.\n• Linguaggio di programmazione: Java `e stato scelto per la sua robustezza, porta-\nbilit`a e ampia diffusione nel contesto enterprise.\n• Accesso al database: La connessione con il database `e stata gestita tramite JDBC\n(Java Database Connectivity), permettendo un’interazione diretta e performante con\nil database relazionale.\n• Database: PostgreSQL 17 `e stato impiegato come sistema di gestione del database\n(DBMS), garantendo affidabilit`a, integrit`a e supporto avanzato per i dati strutturati.\n• Testing: I test unitari sono stati realizzati con JUnit, assicurando il corretto funzion-\namento delle singole componenti software e facilitando la manutenzione del codice.\n• Modellazione: Per la progettazione del sistema sono stati utilizzati diagrammi UML,\nUse Case, ER realizzati con l’ausilio di StarUML, strumento professionale per la model-\nlazione visuale.\n• Mockup: Balsamiq `e stato adottato per la realizzazione dei mockup delle interfacce\nutente, permettendo una rapida definizione e validazione del design.\n• Integrazione AI: `E stata implementata un’integrazione con ChatGPT per generare\ndati di test automatizzati, riducendo la necessit`a di popolamento manuale del database\ne migliorando l’efficienza dei test.\n• Controllo versione: Il codice sorgente `e gestito tramite un repository GitHub, ac-\ncessibile all’indirizzo: github.com/ciabatti/LEARN-IT.\n2\n",
  "4": "Lorenzo Ciabatti\nIngegneria del Software\n• Redazione documentale: La relazione tecnica `e stata stesa utilizzando Overleaf,\npiattaforma collaborativa basata su LaTeX, per garantire un’elevata qualit`a tipografica\ne facilit`a di revisione.\n3\n",
  "5": "Lorenzo Ciabatti\nIngegneria del Software\n2\nProgettazione\n2.1\nUse Case Diagram\nL’applicativo prevede tre attori principali: l’Amministratore, i Formatori e le Aziende.\nL’Amministratore `e responsabile della gestione complessiva del sistema, incluse le at-\ntivit`a di pianificazione, modifica e eliminazione dei corsi di formazione, nonch´e della gestione\ndei turni dei formatori. Supervisiona inoltre la comunicazione con le aziende, in particolare\nattraverso l’invio di notifiche relative a iscrizioni e pagamenti.\nLe Aziende, in qualit`a di enti iscrittori, si occupano dell’iscrizione dei propri impiegati ai\ncorsi, fornendo le informazioni richieste. Hanno accesso al calendario delle attivit`a formative\ne possono visualizzare i materiali multimediali caricati dai formatori.\nI Formatori possono consultare i propri turni di lavoro e l’elenco degli impiegati iscritti\nai corsi di loro competenza. Per ogni partecipante `e possibile visualizzare i dati anagrafici,\nil ruolo e l’azienda di provenienza. I formatori sono inoltre responsabili del caricamento e\ndella gestione dei contenuti didattici multimediali (slide, video, ecc.) relativi ai corsi.\nIn figura 1 `e mostrato il diagramma complessivo dei casi d’uso dell’applicativo.\nLe\nfigure 2, 3 e 4 rappresentano i casi d’uso suddivisi per attore, fornendo una visione dettagliata\ne strutturata delle funzionalit`a associate a ciascun ruolo.\nFigure 1: Use case diagram completo\nFigure 2: Use case diagram Admin\n4\n",
  "6": "Lorenzo Ciabatti\nIngegneria del Software\nFigure 3: Use case diagram Trainer\nFigure 4: Use case diagram Company\n2.2\nUse case templates\nAl fine di approfondire il comportamento del sistema in risposta alle interazioni degli utenti,\nsono stati selezionati e descritti, mediante l’utilizzo di template standard, alcuni casi d’uso\nrappresentativi dell’applicazione. In particolare, sono stati analizzati tre casi d’uso relativi\nall’Amministratore, due riguardanti i Formatori e due associati alle Aziende. Tali casi\nd’uso evidenziano le funzionalit`a principali offerte a ciascuna categoria di attori e permettono\ndi delineare con maggiore precisione le responsabilit`a e i flussi operativi del sistema.\n5\n",
  "7": "Lorenzo Ciabatti\nIngegneria del Software\nUC-1\nSet Course\nLevel\nUser goal\nMain Actors\nAdmin\nDescription\nL’utente di tipo Admin sceglie un corso stabilendone giorno,\norario e descrizione.\nBasic Course\n1. Utente accede alla pagina CREATE COURSE\n2. Il sistema mostra un form da compilare con i campi: Date,\nTime, Description e Focus (il macro-argomento)\n3. Una volta riempiti i campi, l’utente preme il pulsante CRE-\nATE\n4. Se tutti i valori sono corretti, il sistema registra il corso e no-\ntifica alle Aziende e ai Formatori la presenza della nuova lezione\nAlternative Course\n4.\nSe i valori inseriti non hanno il formato richiesto o sono\ninvalidi, il sistema lo segnala all’utente\nTable 1: UC-1: Set Course (vedi figura: 5)\nUC-2\nDelete Course\nLevel\nUser goal\nMain Actors\nAdmin\nDescription\nL’utente di tipo Admin sceglie un corso stabilendone giorno, orario e\ndescrizione.\nBasic Course\n1. Utente accede alla pagina DELETE COURSE\n2. Il sistema mostra un una lista dei corsi programmati\n3. L’utente seleziona il corso che vuole eliminare e conferma la scelta\nmediante il bottone DELETE SELECTED COURSE\n4.\nIl sistema elimina il corso e notifica alle Aziende e ai Formatori\nl’eliminazione della lezione selezionata\nTable 2: UC-2: Delete Course (vedi figura: 6)\nUC-3\nView Employee List\nLevel\nUser goal\nMain Actors\nAdmin, Trainer\nDescription\nL’utente di tipo Admin o Trainer visualizza la lista degli impiegati\niscritti a un corso\nBasic Course\n1. Utente seleziona la voce VIEW EMPLOYEES LIST\n2. Il sistema mostra una lista degli impiegati iscritti ai corsi di for-\nmazione\nTable 3: UC-3: View Employee List (vedi figura: 7)\nUC-4\nUpload Videos and Slides\nLevel\nUser goal\nMain Actors\nTrainer\nDescription\nL’utente di tipo Trainer carica le slide e i video relativi a un\ncorso.\nBasic Course\n1. L’utente seleziona la voce UPLOAD VIDEO AND SLIDES\ndalla barra laterale\n2. Il sistema mostra due file picker, uno per ogni tipologia di\nmateriale\n3. L’utente pu`o scegliere dal proprio PC il materiale da caricare\ne lo carica mediante l’apposito bottone\n4. Se il caricamento va a buon fine, le aziende vengono informate\ndella presenza di nuovi contenuti.\nAlternative Course\nSe il caricamento non va a buon fine, l’utente viene notificato.\nTable 4: UC-4: Upload Videos and Slides (vedi figura: 8)\n6\n",
  "8": "Lorenzo Ciabatti\nIngegneria del Software\nUC-5\nPay Fee\nLevel\nUser goal\nMain Actors\nCompany\nDescription\nL’utente di tipo Company pu`o vedere i pagamenti che deve ancora\neffettuare e successivamente saldare eventuali fatture.\nBasic Course\n1. L’utente seleziona PAY FEE nel men`u laterale e visualizza la lista\ndegli impiegati della propria azienda iscritti ai corsi, insieme allo stato\ndelle fatture.\n2. Selezionando un impiegato con saldo non ancora pagato, pu`o pro-\ncedere al pagamento tramite l’apposito bottone.\n3. La tariffa per ogni incontro si riduce in funzione del numero di imp-\niegati iscritti: `e intera solo se l’ azienda ha un unico partecipante.\n4. Il sistema calcola automaticamente l’importo totale da versare.\nTable 5: UC-5: Pay Fee (vedi figura: 9)\nUC-6\nRegister Employee\nLevel\nUser goal\nMain Actors\nCompany\nDescription\nL’utente di tipo Company iscrive un impiegato a un corso.\nBasic Course\n1.\nL’utente seleziona la voce REGISTER EMPLOYEE dalla\nbarra laterale.\n2. Il sistema mostra un modulo in cui inserire le informazioni\ndell’impiegato e il numero di lezioni che seguir`a.\n3. Tramite il tasto GO! la registrazione viene effettuata.\nAlternative Course\nSe il modulo non `e compilato correttamente, l’utente viene no-\ntificato.\nTable 6: UC-6: Register Employee (vedi figura: 10)\n2.3\nMockup dell’interfaccia utente\nA completamento della progettazione dei casi d’uso, sono stati realizzati dei mockup per\nrappresentare graficamente l’interfaccia utente associata alle principali funzionalit`a del sis-\ntema. I prototipi hanno lo scopo di illustrare, in modo intuitivo e visuale, il comportamento\natteso dell’applicativo in risposta alle interazioni degli attori.\nOgni schermata `e stata sviluppata utilizzando lo strumento Balsamiq Mockups, con\nl’intento di mantenere una rappresentazione semplice ma efficace dei componenti grafici.\nI mockup sono stati progettati seguendo i casi d’uso precedentemente descritti, rispettando\ni flussi logici previsti e agevolando l’attivit`a di sviluppo successiva.\nLe figure che seguono mostrano i mockup relativi a ciascuno dei casi d’uso documentati\nnella sezione precedente.\n7\n",
  "9": "Lorenzo Ciabatti\nIngegneria del Software\nFigure 5: Mockup dell’interfaccia per la creazione di un corso (UC-1, vedi Tabella 1).\nFigure 6: Mockup dell’interfaccia per l’eliminazione di un corso (UC-2, vedi Tabella 2).\n8\n",
  "10": "Lorenzo Ciabatti\nIngegneria del Software\nFigure 7: Mockup della visualizzazione degli impiegati iscritti (UC-3, vedi Tabella 3).\nFigure 8: Mockup per il caricamento dei materiali da parte dei formatori (UC-4, vedi Tabella 4).\n9\n",
  "11": "Lorenzo Ciabatti\nIngegneria del Software\nFigure 9: Mockup per la gestione e il pagamento delle quote di iscrizione (UC-5, vedi Tabella 5).\nFigure 10: Mockup per l’iscrizione di un impiegato da parte di un’azienda (UC-6, vedi Tabella 6).\n10\n",
  "12": "Lorenzo Ciabatti\nIngegneria del Software\n3\nUML e Struttura\n3.1\nPackage Diagram\nIl diagramma dei package implementati `e stato realizzato utilizzando StarUML, al fine di\nrappresentare graficamente la struttura statica del sistema e le relazioni tra i diversi com-\nponenti. L’architettura dell’applicativo `e suddivisa in tre principali package, ognuno con\nresponsabilit`a ben distinte secondo il principio della separazione delle responsabilit`a:\n• Business Logic: contiene le classi deputate alla gestione della logica applicativa,\ninclusi i servizi e i casi d’uso.\n• Domain Model: racchiude le entit`a principali del dominio, modellando i concetti\nchiave e le loro relazioni.\n• Object-Relational Mapping (ORM): comprende le componenti responsabili della\npersistenza, mappando le entit`a del dominio alle corrispondenti tabelle nel database\nrelazionale.\nTale suddivisione favorisce una maggiore modularit`a e manutenibilit`a del sistema, ren-\ndendo pi`u agevole l’estensione o la modifica di singole funzionalit`a.\nFigure 11: Package diagram di LEARN-IT\n3.2\nClass Diagram\nIn questa sezione vengono presentati i diagrammi delle classi relativi ai packages prece-\ndentemente mostrati nel Package Diagram. Ogni diagramma di classe illustra la struttura\ninterna del rispettivo package, evidenziando le classi implementate, i loro attributi, metodi\ne le relazioni tra di esse (associazioni, ereditariet`a, dipendenze).\nL’obiettivo `e fornire una visione dettagliata dell’architettura software a livello di pro-\ngettazione, utile per comprendere l’organizzazione del codice, la responsabilit`a delle singole\ncomponenti e le interazioni tra i vari moduli del sistema.\n3.2.1\nBusiness Logic\nIl package Business Logic raccoglie le classi responsabili dell’implementazione dei casi d’uso\ndel sistema. Per ciascun attore `e definito un apposito controller incaricato della gestione\ndelle operazioni previste, coordinando l’interazione tra il Domain Model e i componenti di\npersistenza dell’ORM. All’interno del package `e inoltre presente la classe Notifier, respon-\nsabile della gestione e dell’invio delle email di notifica agli utenti coinvolti.\nSegue il diagramma delle classi contenute nella Business Logic:\n11\n",
  "13": "Lorenzo Ciabatti\nIngegneria del Software\nFigure 12: Class diagram del package Business Logic\n3.2.1.1\nAdmin\nLa classe Admin implementa le funzionalit`a riservate all’amministratore\ndel sistema, consentendogli la gestione delle principali entit`a applicative. In particolare, il\nmetodo setCourse(), visibile in figura 13, permette l’inserimento di un nuovo corso nel calen-\ndario, mentre modifyCourse() e deleteCourse() ne consentono rispettivamente la modifica e\nl’eliminazione. Ogni variazione sui corsi genera notifiche automatiche inviate tramite email\nalle aziende e ai formatori interessati.\nPer quanto riguarda la pianificazione del personale, l’Admin pu`o creare, modificare o\neliminare i turni di lavoro dei formatori mediante i metodi createWorkshifts(), modifyWork-\nshift() e deleteWorkshift(). La visualizzazione dei turni programmati `e invece gestita tramite\nviewWorkshifts(). Anche in questo caso, ogni aggiornamento genera una notifica automatica\nai formatori coinvolti.\nCompletano le funzionalit`a della classe i metodi viewEmployeesList() e viewEmployee-\nInfo(), che consentono rispettivamente la visualizzazione dell’elenco dei dipendenti iscritti e\ndei relativi dati anagrafici e lavorativi. Infine, attraverso paymentReminder(), l’Admin pu`o\ninviare promemoria di pagamento alle aziende.\nFigure 13: setCourse()\n3.2.1.2\nTrainerController\nLa classe TrainerController fornisce le funzionalit`a op-\nerative a supporto delle attivit`a dei formatori.\nIl metodo viewWorkshifts() consente la\nvisualizzazione del proprio piano turni, mentre viewCourses() permette di consultare i corsi\nassegnati. I metodi viewEmployeesList() e viewEmployeesInfo() offrono strumenti per ac-\ncedere all’elenco dei partecipanti e ai relativi dettagli.\nRelativamente alla gestione dei materiali didattici, la classe include uploadSlideVideo()\nper il caricamento dei contenuti, la cui implementazione `e visibile in figura 14, deleteS-\nlideVideo() per la loro rimozione e viewSlideVideo() per la consultazione. Ogni modifica\napportata ai materiali comporta l’invio automatico di notifiche email alle aziende, assicu-\nrando una comunicazione tempestiva e trasparente.\n12\n",
  "14": "Lorenzo Ciabatti\nIngegneria del Software\nFigure 14: uploadSlideVideos()\n3.2.1.3\nCompanyController\nLa classe CompanyController racchiude le funzionalit`a\ndestinate alle aziende degli impiegati iscritti ai corsi. Il metodo registerEmployee() con-\nsente l’iscrizione del proprio dipendente al corso, il codice che implementa tale funzione `e\nvisibile successivamente in figura 15, mentre payFee() permette il versamento della quota\ndi iscrizione. Le aziende possono inoltre consultare l’elenco dei corsi pianificate tramite il\nmetodo viewCourses(), accedere alle dispense multimediali pubblicate con viewSlideVideo()\ne visualizzare le informazioni relative ai propri dipendenti attraverso viewEmployeeInfo().\nFigure 15: registerEmployee()\n3.2.1.4\nNotifier\nLa classe Notifier ha il compito di gestire l’invio di email personaliz-\nzate alle aziende (Company) e ai formatori (Trainer) del sistema. Implementata secondo il\npattern Singleton, essa garantisce che esista una sola istanza condivisa, accessibile tramite\nil metodo getInstance(). Le funzionalit`a principali sono offerte dai metodi sendEmailCom-\npany() e sendEmailTrainer(), che inviano messaggi email HTML contenenti un testo per-\nsonalizzato, il nome del destinatario e un’immagine. La comunicazione avviene attraverso il\nprotocollo SMTP, con autenticazione dell’utente mittente tramite un account Gmail config-\nurato nella classe stessa. Questo componente centralizza e uniforma le notifiche inviate per\neventi rilevanti, come ad esempio il pagamento delle quote, migliorando la comunicazione\ntra il sistema e i suoi utenti.\n3.2.2\nDomain Model\nIl Domain Model rappresenta il nucleo concettuale dell’applicazione e contiene le classi che\nmodellano i concetti principali del dominio. Queste classi sono indipendenti dalla logica di\nbusiness e dalla persistenza, e riflettono fedelmente le entit`a, le regole e le relazioni proprie\ndel sistema.\nDi seguito `e mostrato il diagramma delle classi che compongono il Domain Model:\n13\n",
  "15": "Lorenzo Ciabatti\nIngegneria del Software\nFigure 16: Class diagram del package Domain Model (`e presente un’immagine di dimensione mag-\ngiore alla fine del documento, figura:\n28)\n3.2.2.1\nSubscription\nContiene le informazioni relative all’iscrizione di un impiegato\nai corsi. Gli attributi sono il numero di incontri per cui si vuole effettuare l’iscrizione e un\nbooleano che indica se la quota di essa `e stata pagata. Sono presenti anche un riferimento\nall’oggetto di tipo Employee che rappresenta l’impiegato a cui `e associata l’iscrizione e a un\noggetto di tipo FeeStrategy: un’interfaccia spiegata nel paragrafo successivo, che indica se\nl’impiegato ha altri colleghi iscritti, in modo tale che sia possibile applicare la tariffa corretta\nper ciascuno dei due casi.\n3.2.2.2\nFeeStrategy, SingleEmployeeFee e MultipleEmployeeFee\nQueste tre classi\nrealizzano il design pattern Strategy che permette di esporre diverse implementazioni di un\nmetodo in base all’istanza che un oggetto realizza tra le diverse implementazioni dell’interfaccia\nprincipale; nel caso specifico, l’interfaccia principale `e FeeStrategy, mentre le implementazioni\nsono SingleEmployeeFee e MultipleEmployeeFee. L’obiettivo `e quello di dare diverse imple-\nmentazioni del metodo getFee(), che restituisce la quota intera se il viene iscritto un solo\nimpiegato, oppure la quota scontata se l’azienda decide di iscriverne pi`u di uno. La scelta\ndiquesta soluzione oltre sembrare adatta al caso, permette di dare informazioni aggiuntive\nper ogni implementazione, come per esempio l’attributo DISCOUNT nella classe Multi-\npleEmployeeFee. Inoltre una soluzione di questo tipo permette una maggior apertura alla\nmodifica e alla eventuale estensione con l’aggiunta di una nuova implementazione.\n3.2.2.3\nEmployee\n`E la classe che rappresenta ogni impiegato iscritto ai corsi. I suoi\nattributi esplicitano i riferimenti identificativi e personali dell’ impiegato: nome, cognome,\ncodice identificativo, et`a e ruolo all’interno dell’azienda . Sono inoltre presenti un riferimento\na un oggetto di tipo Subscription che contiene dettagli specificatamente relativi all’iscrizione\ne un oggetto di tipo Company che rappresenta l’azienda per cui lavora.\n3.2.2.4\nCompany\nRappresenta un’ azienda che intende iscrivere un impiegato a un\ncorso di formazione. Ha attributi come un codice identificativo, nome, indirizzo, numero\ndi telefono, email e una lista di oggetti di tipo Employee che rappresentano i dipendenti\niscritti.\n3.2.2.5\nTrainer\nClasse utilizzata per incarnare un formatore che svolger`a un corso. Gli\nattributi principali di tale classe so\nnome, cognome, email e una lista di oggetti di tipo\nWorkshift che definisce i suoi turni di lavoro.\n3.2.2.6\nWorkshift\nLa classe Workshift rappresenta un turno di lavoro. Essa `e carat-\nterizzata da attributi che definiscono la data e orario di inizio del corso, fondamentali per\nla pianificazione e la gestione delle attivit`a dei formatori.\n3.2.2.7\nMaterial, Slide e Video\n`E una classe astratta che modella un file multime-\ndiale caricato da un formatore, con l’obiettivo di renderlo fruibile. Gli attributi principali\nincludono la data e l’orario di caricamento, il nome del file, un array di byte che rappre-\nsenta il contenuto effettivo del file, e un riferimento all’oggetto Trainer che identifica chi\n14\n",
  "16": "Lorenzo Ciabatti\nIngegneria del Software\nha inserito il contenuto. Le classi Slide e Video estendono Material, distinguendo cos`ı due\ndiverse tipologie di contenuti multimediali, rispettivamente blocchi di slide e filmati.\n3.2.2.8\nCourse\nLa classe Course modella un corso svolto. Essa possiede attributi che\nindicano la data e l’ora in cui l’attivit`a ha luogo, una descrizione testuale del corso stesso,\ne un riferimento a un oggetto di tipo FocusCourse, che categorizza il corso in una specifica\ntipologia.\n3.2.2.9\nFocusCourse\nFocusCourse `e un tipo enum che elenca tutte le possibili categorie\ndi corsi offerti. Questa implementazione `e stata scelta per la sua semplicit`a, chiarezza e\nfacilit`a di estensione futura, garantendo al contempo una tipizzazione sicura e un controllo\nrigoroso sulle categorie consentite.\n3.2.3\nObject-Relational Mapping (ORM)\nIl package Object-Relational Mapping ha il compito di gestire la persistenza dei dati, fun-\ngendo da strato intermedio tra il Domain Model e il sistema di gestione del database re-\nlazionale (RDBMS). In particolare, contiene le classi DAO, ognuna delle quali `e dedicata\nalla gestione della persistenza di una specifica entit`a del dominio.\nLe classi DAO incapsulano la logica di accesso ai dati, fornendo metodi per operazioni\nCRUD (Create, Read, Update, Delete) e interfacciandosi direttamente con le tabelle del\ndatabase. Questa separazione delle responsabilit`a consente di mantenere il Domain Model\nindipendente dai dettagli implementativi relativi alla persistenza, migliorando la manuteni-\nbilit`a e testabilit`a del sistema.\nTutte le interazioni con il database, come la registrazione di una nuova sottoscrizione,\nla modifica delle informazioni di un impiegato o il recupero dei corsi pianificati, vengono\ndunque demandate alle DAO, che si occupano anche della gestione delle transazioni e della\nconnessione al database.\nSuccessivamente sono elencate le classi appartenenti a questo\npackage ed evidenziati i metodi per effettuare operazioni di inserimento, visualizzazione\ne cancellazione per alcune di esse.\nFigure 17: Class diagram del package ORM\n3.2.3.1\nConnectionManager\nLa classe ConnectionManager `e responsabile della ges-\ntione della connessione a un database PostgreSQL utilizzando JDBC. Essa implementa il Sin-\ngleton Pattern per garantire che esista una sola istanza della connessione durante l’esecuzione\ndel programma. Il metodo getConnection() verifica se la connessione `e gi`a attiva e, in caso\ncontrario, la crea utilizzando il driver JDBC. Questo approccio consente di ottimizzare l’uso\ndelle risorse e ridurre il carico sul database, evitando la creazione ripetitiva di connessioni.\nDi seguito il codice che implementa ci`o che `e stato descritto:\n15\n",
  "17": "Lorenzo Ciabatti\nIngegneria del Software\nFigure 18: ConnectionManager.java\n3.2.3.2\nSubscriptionDAO\nLa classe SubscriptionDAO si occupa della gestione delle\nentit`a Subscription, fornendo metodi per la creazione, aggiornamento e recupero delle is-\ncrizioni. Il metodo getEmployeeInfo() prende in input l’identificativo dell’impiegato e resti-\ntuisce l’iscrizione corrispondente, caratterizzata da tre parametri: la durata dell’iscrizione,\nl’identificativo della strategia tariffaria (che pu`o variare in base al numero di impiegati is-\ncritti), e un valore booleano che indica se la quota `e stata pagata. Il metodo editFeeStrategy()\ngestisce la modifica della strategia tariffaria, passando da SingleEmployeeFee a MultipleEm-\nployeeFee quando vengono iscritti pi`u dipendenti dallo stessa ditta. Per il monitoraggio dei\npagamenti, il metodo getCompanyNotPaid() (figura : 19 )restituisce l’elenco delle aziende\ncon iscrizioni non ancora saldate. Una volta effettuato il pagamento, il metodo editFeePaid()\naggiorna lo stato dell’iscrizione impostando il booleano a true.\nFigure 19: getCompanyNotPaid()\n3.2.3.3\nWorkshiftDAO\nLa classe WorkshiftDAO `e responsabile della gestione delle\nentit`a Workshift e della tabella associativa workshifts trainer, che mappa i turni di lavoro\nassegnati ai singoli formatori. Oltre ai metodi per l’inserimento e la rimozione di turni,\nla classe fornisce il metodo modify(), che consente di aggiornare un turno assegnato a un\nformatore sostituendolo con uno nuovo. Il metodo getWorkshifts() restituisce tutti i turni\ndisponibili, mentre getIndividualWorkshift() recupera tutti i turni associati a un singolo\nformatore. Il metodo getAllIndividualWorkshift() produce una panoramica completa di tutti\ni formatori e dei rispettivi turni. Infine, il metodo getDates() restituisce l’elenco delle date\nrelative al periodo di svolgimento dei corsi, utile per la pianificazione dei turni.\n3.2.3.4\nCompanyDAO\nLa classe CompanyDAO gestisce la persistenza delle informazioni\nrelative alle aziende. Oltre ai metodi canonici di inserimento e cancellazione, offre il metodo\ngetCompany(), che consente di recuperare un’azienda dato il suo codice identificativo, e\ngetAllCompany(), che restituisce un elenco completo di tutte le aziende presenti nel sistema.\n3.2.3.5\nTrainerDAO\nLa classe TrainerDAO si occupa della gestione degli formatori.\nInclude, oltre ai metodi base per l’inserimento e la cancellazione (figura: 20, il metodo\ngetTrainerShifts(), che restituisce un’associazione tra formatori e i loro turni di lavoro. Il\n16\n",
  "18": "Lorenzo Ciabatti\nIngegneria del Software\nmetodo getTrainerByEmail() permette di cercare un formatore a partire dalla sua email,\nfunzione utile nei processi di autenticazione o comunicazione, mentre getAllTrainer() resti-\ntuisce l’elenco completo di tutti i formatori registrati.\nFigure 20: deleteTrainer()\n3.2.3.6\nMaterialDAO\nLa classe MaterialDAO gestisce la persistenza dei contenuti mul-\ntimediali nel sistema. Il metodo uploadMaterial() riceve in ingresso un parametro filename,\nche rappresenta il percorso del file da caricare nel sistema, anzich´e un oggetto Material vero\ne proprio. Per il recupero di un contenuto multimediale specifico `e disponibile il metodo\ngetMaterialbyfilename(), che consente di ottenere l’oggetto Material associato a un deter-\nminato percorso. La classe include inoltre metodi standard per la gestione dei dati, come\ndeleteMaterial(), per rimuovere un file dal sistema, e getAllMedia(), che restituisce una lista\ncompleta di tutti i media archiviati.\n3.2.3.7\nEmployeeDAO\nLa classe EmployeeDAO `e responsabile della gestione dei dati\nrelativi ai dipendenti iscritti ai corsi di formazione. Oltre ai metodi canonici per l’inserimento\ne la rimozione, la classe offre il metodo getAllEmployees(), che restituisce una lista di tutti\ngli impiegati registrati. Il metodo getEmployee() consente di ottenere un oggetto Employee\na partire dal suo codice identificativo.\n`E inoltre disponibile il metodo getEmployeesBy-\nCompany(), che restituisce una lista di impiegati associati a una determinata azienda, pren-\ndendo in ingresso l’identificativo della stessa azienda. Infine, il metodo getCompany() perme-\ntte di recuperare l’oggetto Company associato a un dipendente, dato il codice identificativo\ndi quest’ultimo.\nNella Figura\n21 possiamo vedere come il metodo getEmployee() consenta di recuperare\nun dipendente dal database fornendo il relativo codice identificativo. Dopo aver ottenuto\nuna connessione tramite ConnectionManager, viene eseguita una query SQL che seleziona\ntutti i dati dell’impiegato corrispondente. Se la query restituisce un risultato, i valori ven-\ngono estratti dall’oggetto ResultSet e utilizzati per creare un’istanza di Employee. Inoltre,\nil metodo gestisce il tipo di strategia di pagamento associata al dipendente, scegliendo tra\nMultipleEmployeesFee e SingleEmployeeFee in base al valore dell’attributo idstrategy. Infine,\nl’oggetto Subscription viene istanziato con le informazioni estratte e associato al dipendente\nprima di restituire il risultato. Se nessun dipendente corrisponde al codice fornito, il metodo\nrestituisce null.\nFigure 21: getEmployee()\n17\n",
  "19": "Lorenzo Ciabatti\nIngegneria del Software\n3.2.3.8\nCourseDAO\nLa classe CourseDAO si occupa della gestione dei corsi di for-\nmazione pianificati.\nOltre alle operazioni di inserimento, aggiornamento e cancellazione,\nfornisce il metodo getAllCourses(), che restituisce una lista di tutti i corsi disponibili nel\nsistema. Il metodo getCourseByDateAndTime() consente di recuperare un corso specifica\nfornendo in input una data e un orario: se esiste un’attivit`a pianificata per quel momento,\nviene restituito l’oggetto corrispondente. La classe gestisce inoltre la tabella focuscourse,\nche contiene i possibili macro-argomenti su cui i corsi sono improntati. A tal fine, sono im-\nplementati i metodi getId(), che restituisce l’identificativo numerico associato a un oggetto\nFocusCourse, e getFocusCourse(), che permette di ottenere l’oggetto FocusCourse corrispon-\ndente a un dato identificativo numerico.\nSotto si mostra il metodo insertCourse() che ha il compito di inserire un nuovo corso nella\nbase di dati. Per farlo, ottiene una connessione al database tramite la classe ConnectionManager,\nquindi prepara una query SQL parametrizzata per l’inserimento dei dati. La data del corso\nviene trasformata da una stringa in un oggetto java.sql.Date, mentre l’orario viene conver-\ntito in un java.sql.Time. Successivamente, vengono impostati i valori nella PreparedStatement\ne la query viene eseguita con executeUpdate().\nInfine, il metodo chiude la dichiarazione\nper liberare risorse. Questa gestione garantisce una corretta memorizzazione dei dati nella\ntabella courses.\nFigure 22: insertCourse()\n3.3\nDatabase\nPer la gestione della persistenza dei dati `e stato adottato PostgreSQL, un sistema di gestione\ndi basi di dati relazionali ad oggetti, open-source e gratuito, ampiamente utilizzato per la\nsua affidabilit`a, scalabilit`a e compatibilit`a con le tecnologie Java impiegate nell’applicazione.\nLe figure 23 e 24 illustrano rispettivamente il diagramma Entity-Relationship, che descrive\nle entit`a del dominio e le loro relazioni, e lo schema logico del database, con le tabelle\nrelazionali e i vincoli di integrit`a.\n18\n",
  "20": "Lorenzo Ciabatti\nIngegneria del Software\nFigure 23: Diagramma Entity-Relationship del database\nFigure 24: Schema logico del database relazionale\n19\n",
  "21": "Lorenzo Ciabatti\nIngegneria del Software\n4\nTesting\nPer la verifica del codice, `e stato impiegato il framework JUnit, attraverso il quale sono stati\nsviluppati test per tutte le classi implementate, ad eccezione di quelle appartenenti al domain\nmodel, poich´e contengono esclusivamente metodi di accesso ai dati, come getter e setter, che\nnon necessitano di specifici test unitari. L’organizzazione dei test segue la struttura mostrata\nin figura 25, garantendo una copertura adeguata e un’efficace validazione delle funzionalit`a\nimplementate.\nFigure 25: Organizzazione dei test\n4.1\nTest package Controllers\nIl package controllers contiene le classi di test dedicate alla verifica delle funzionalit`a\nprincipali dei vari controller dell’applicazione, come amministratore, formatore e azienda.\nQuesti test assicurano che le operazioni critiche come la gestione di materiali didattici, la\nconsultazione di dati utente e l’interazione con il database siano implementate correttamente\ne funzionino come previsto in scenari realistici.\nPer assicurare la coerenza dei test ed evitare interferenze tra i casi di prova, ciascun test\n`e strutturato con blocchi try-catch per la gestione delle eccezioni. Inoltre, al termine di\nogni test viene eseguita una fase di pulizia dei dati inseriti, assicurando cos`ı l’indipendenza\ne la ripetibilit`a dei test. Questo approccio contribuisce alla stabilit`a complessiva del sistema\ne alla qualit`a del software.\n4.1.1\nAdminTest\nLa classe AdminTest si occupa della verifica dei principali metodi della classe Admin, re-\nsponsabile della gestione delle funzionalit`a amministrative del sistema, come la creazione,\nmodifica, visualizzazione ed eliminazione dei corsi, nonch´e la gestione degli impiegati tramite\nl’uso dei rispettivi oggetti DAO, simulando cos`ı scenari d’uso concreti.\nIl metodo setCourse() viene testato per verificare che i dati relativi a un nuovo corso\nvengano correttamente salvati nel database e che i valori persistiti siano conformi a quelli\nprevisti. Con modifyCourse() si verifica la possibilit`a di aggiornare le informazioni di un\ncorso esistente, assicurandosi che le modifiche vengano applicate senza perdita di dati. Il\nmetodo deleteCourse() accerta la corretta eliminazione di un corso, verificando che non sia\npi`u presente nel sistema. Il metodo viewCourses() (figura: 26) permette invece di controllare\nla corretta restituzione della lista dei corsi, mentre viewEmployeesList() consente di validare\nl’estrazione della lista dei dipendenti registrati.\nI test coprono l’intero ciclo di vita di un corso: inserimento, visualizzazione, modifica e\ncancellazione, oltre alla gestione degli impiegati. Ogni test verifica la corretta registrazione e\nmanipolazione dei dati nel database, contribuendo a garantire l’affidabilit`a delle operazioni\nsvolte dalla componente amministrativa del sistema.\n20\n",
  "22": "Lorenzo Ciabatti\nIngegneria del Software\nFigure 26: viewCourses()\n4.1.2\nCompanyControllerTest\nLa classe CompanyControllerTest verifica il corretto funzionamento delle funzionalit`a of-\nferte dalla classe CompanyController, responsabile della gestione operativa delle aziende,\ndei dipendenti, dei materiali didattici e dei corsi.\nIl metodo registerEmployee() viene testato assicurandosi che l’inserimento di un nuovo\ndipendente in un’azienda comporti la corretta persistenza delle informazioni anagrafiche e\ncontrattuali, come anche l’assegnazione automatica della strategia tariffaria pi`u adeguata,\nin base al numero di dipendenti gi`a associati all’azienda. Viene inoltre verificata la modifica\ndella strategia tariffaria per i dipendenti esistenti quando viene superata la soglia prevista.\nIl metodo che visualizza i materiali multimediali, viewSlidesAndVideos(), consente di\ntestare il recupero dei file didattici presenti nel sistema. A tale scopo, un trainer fittizio\ncarica un file di test che viene poi recuperato e validato, confermando la corretta associazione\ncon l’utente e la corretta scrittura su file system.\nLa funzionalit`a di visualizzazione dei corsi offerti dal sistema viene testata tramite view-\nCourses(), assicurandosi che i dati dei corsi inseriti siano accessibili correttamente. Viene\nquindi inserito un corso di test e successivamente recuperato per verificare la coerenza delle\ninformazioni.\nInfine, con il metodo viewEmployeeInfo() viene verificata la corretta restituzione delle\ninformazioni dei dipendenti associati a una determinata azienda. Il test accerta che tutti gli\nattributi anagrafici e contrattuali del dipendente siano correttamente persistiti e successiva-\nmente accessibili tramite il controller.\n4.1.3\nTrainerControllerTest\nRappresenta una suite di test dedicata alla verifica del comportamento della classe Trainer-\nController. Essa include metodi per testare operazioni fondamentali eseguibili da un for-\nmatore, come il caricamento, la visualizzazione e la cancellazione di materiale didattico (slide\ne video), nonch´e la consultazione delle informazioni relative ai dipendenti, ai corsi e ai turni\ndi lavoro. I test simulano l’interazione con il database tramite l’aggiunta e rimozione di dati\ntemporanei e verificano la correttezza dei risultati attesi, utilizzando metodi di asserzione.\n21\n",
  "23": "Lorenzo Ciabatti\nIngegneria del Software\n4.2\nTest package ORM\nPer garantire una corretta validazione delle operazioni sui dati, tutte le classi DAO imple-\nmentano test unitari seguendo un ordine ben definito, stabilito mediante il framework JU-\nnit e l’annotazione @TestMethodOrder(MethodOrderer.OrderAnnotation.class). Questo\napproccio assicura che i test vengano eseguiti in una sequenza logica e coerente, evitando\nproblemi legati alla dipendenza tra le operazioni.\nIn particolare, la struttura dei test prevede:\n• Test di inserimento: verificano che i dati siano correttamente registrati nel database.\n• Test di recupero: controllano che le informazioni precedentemente inserite possano\nessere lette e utilizzate correttamente.\n• Test di manipolazione: assicurano che le operazioni di aggiornamento e modifica\nfunzionino senza errori.\n• Test di eliminazione: garantiscono che i dati possano essere rimossi senza compro-\nmettere l’integrit`a del database e mantenendo l’ambiente di test pulito.\nL’adozione di questa metodologia ha permesso di migliorare la robustezza delle operazioni\ndi accesso ai dati, riducendo il rischio di errori e garantendo maggiore affidabilit`a al sistema.\nQuesto approccio `e stato implementato grazie all’ausilio dell’Intelligenza Artificiale, che ha\nsuggerito strategie ottimali per organizzare i test in modo pi`u efficace.\n4.2.1\nTrainerDAOTest\nTra le varie classi, `e stato scelto di approfondire TrainerDAOTest poich´e rappresenta un\nesempio chiaro della metodologia utilizzata e mostra l’interazione tra pi`u funzionalit`a legate\nalla gestione dei formatori.\nIl primo test, testAddTrainer, si occupa di inserire un nuovo formatore, stabilendo una\nbase dati da cui partire. I successivi test, testGetTrainerByEmail, testGetAllTrainers e test-\nGetTrainersShifts, verificano la corretta registrazione e il recupero delle informazioni, assi-\ncurando che i dati siano accessibili in maniera coerente. L’ultimo test, testDeleteTrainer,\ncompleta il ciclo controllando che l’eliminazione del formatore dal database sia eseguita\ncorrettamente, permettendo di mantenere un ambiente di test pulito.\nQuesta classe riflette l’approccio sistematico adottato per tutte le DAO, garantendo\naffidabilit`a e coerenza nella gestione dei dati.\n22\n",
  "24": "Lorenzo Ciabatti\nIngegneria del Software\n23\n",
  "25": "Lorenzo Ciabatti\nIngegneria del Software\n4.3\nRisultati dei test\nL’esecuzione dei test sui package Orm e Controllers ha confermato la correttezza e la stabilit`a\ndelle operazioni implementate. Tutti i 51 test sono stati completati con successo, garantendo\nla validit`a delle funzionalit`a di gestione dei dati e della logica applicativa. Questo risultato\nevidenzia la solidit`a del codice, la coerenza tra i moduli e l’adeguata implementazione delle\nlogiche di accesso e manipolazione delle informazioni. Di seguito vengono riportati i dettagli\ndelle verifiche effettuate e le rispettive conferme di buon funzionamento.\nFigure 27: Risultati dei test effettuati\n24\n",
  "26": "Lorenzo Ciabatti\nIngegneria del Software\nFigure 28: Class diagram del Domain Model in formato orizzontale\n25\n"
}