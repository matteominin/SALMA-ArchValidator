{
  "1": "UNIVERSIT `A DEGLI STUDI DI FIRENZE\nDIPARTIMENTO DI INGEGNERIA DELL’INFORMAZIONE\nProgetto Piattaforma per la Gestione di\nVideogiochi\nAutore:\nSamuele Lattanzi\nN° Matricola:\n7048716\nCorso principale:\nIngegneria del Software\nDocente corso:\nEnrico Vicario\n",
  "2": "Samuele Lattanzi\nIngegneria del Software\nIndice\n1\nIntroduzione\n3\n1.1\nStatement del progetto\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3\n1.2\nArchitettura e strumenti . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3\n1.3\nRelazioni tra i pacchetti . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3\n2\nDocumentazione\n5\n2.1\nUse Case Diagram\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n5\n2.2\nUse Case Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6\n2.3\nMock-Ups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n8\n2.4\nClass Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n11\n2.5\nER Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n11\n3\nImplementazione\n12\n3.1\nDomain Model\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n12\n3.1.1\nUtente . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n12\n3.1.2\nVideogioco . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n12\n3.1.3\nCarrello . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n12\n3.1.4\nLibreria . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n12\n3.1.5\nAbbonamento . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13\n3.1.6\nStatisticheVideogioco\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13\n3.1.7\nAchievement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13\n3.1.8\nAdmin\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13\n3.2\nBusiness Logic\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13\n3.2.1\nUtenteController . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13\n3.2.2\nCarrelloController\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14\n3.2.3\nLibreriaController\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n16\n3.2.4\nCatalogoController . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n17\n3.2.5\nStatisticheController . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n18\n3.2.6\nAchievementController . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n18\n3.2.7\nAdminController . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19\n3.3\nORM (Object-Relational Mapping) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19\n3.3.1\nDatabaseConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19\n3.3.2\nUtenteDAO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19\n3.3.3\nVideogiocoDAO\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n20\n3.3.4\nCarrelloDAO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n21\n3.3.5\nLibreriaDAO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n21\n3.3.6\nAbbonamentoDAO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n22\n3.3.7\nStatisticheVideogiocoDAO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n23\n3.3.8\nAchievementDAO\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n23\n3.3.9\nAdminDAO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n24\n3.4\nDatabase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n24\n4\nTest\n25\n4.1\nBusiness Logic Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n25\n4.1.1\nUtenteControllerTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n25\n4.1.2\nCatalogoControllerTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n26\n4.1.3\nCarrelloControllerTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n27\n4.1.4\nLibreriaControllerTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n29\n4.1.5\nStatisticheControllerTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n31\n4.1.6\nAchievementControllerTest\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n32\n4.1.7\nAdminControllerTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n33\n4.2\nDomain Model Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n34\n4.2.1\nCarrelloTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n34\n4.3\nTest del Pacchetto ORM\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n36\n4.3.1\nVideogiocoDAOTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n36\n4.3.2\nCarrelloDAOTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n37\n4.3.3\nLibreriaDAOTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n39\n1\n",
  "3": "Samuele Lattanzi\nIngegneria del Software\nElenco delle figure\n1\nUse Case Diagram - Utente . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n5\n2\nUse Case Diagram - Admin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n5\n3\nMockup raffigurante un prototipo del menu inziale dell’applicazione . . . . . . . . . . . . . . . .\n8\n4\nMockup raffigurante un prototipo del menu di login . . . . . . . . . . . . . . . . . . . . . . . . .\n9\n5\nMockup raffigurante un prototipo della schermata principale per l’utente . . . . . . . . . . . . . .\n9\n6\nMockup raffigurante un prototipo della visualizzazione del catalogo di videogiochi\n. . . . . . . .\n9\n7\nMockup raffigurante un prototipo della visualizzazione del carrello . . . . . . . . . . . . . . . . .\n10\n8\nMockup raffigurante un prototipo della visualizzazione della libreria . . . . . . . . . . . . . . . .\n10\n9\nMockup raffigurante un prototipo del menu dell’admin . . . . . . . . . . . . . . . . . . . . . . .\n10\n10\nDiagramma di Classe, con suddivisione nei pacchetti Domain Model, Business Logic, ORM . . .\n11\n11\nDiagramma ER: Rappresentazione della struttura delle tabelle create dal DBMS . . . . . . . . . .\n11\n2\n",
  "4": "Samuele Lattanzi\nIngegneria del Software\n1\nIntroduzione\n1.1\nStatement del progetto\nL’obiettivo del progetto `e lo sviluppo di un’applicazione per la gestione di un sistema di vendita di videogiochi.\nL’applicazione offre una piattaforma attraverso cui gli utenti possono esplorare un catalogo di videogiochi, effet-\ntuare ricerche basate su criteri come genere, piattaforma e data di uscita, e aggiungere titoli a un carrello virtuale\nper l’acquisto. Una volta acquistati, i giochi vengono inseriti in una libreria personale dell’utente, che consente di\ngestire i titoli posseduti, permettendo di installarli, disinstallarli o avviarli per giocare. Durante le sessioni di gio-\nco, l’applicazione registra statistiche, come il tempo totale di gioco e permette di sbloccare achievement associati\nai videogiochi. Il sistema prevede inoltre due tipologie di abbonamento mensile, Gold e Silver, che offrono agli\nutenti sconti esclusivi e accesso a una selezione di giochi gratuiti. Per aver accesso a questi abbonamenti e poter\ncomprare i videogiochi che ha inserito nel carrello, un utente ha un fondo, che pu`o ricaricare. `E incluso un ruolo\namministratore (Admin), con funzionalit`a dedicate alla gestione del catalogo, come l’aggiunta, la rimozione e la\nmodifica dei giochi, nonch´e la selezione dei titoli gratuiti per gli abbonati e la possibilit`a di aggiungere, rimuovere\ne modificare gli achievement associati ai giochi.\n1.2\nArchitettura e strumenti\nL’applicazione `e stata progettata seguendo un’architettura modulare, suddivisa in pacchetti distinti per garantire\nchiarezza, manutenibilit`a e scalabilit`a del codice. I principali componenti architetturali sono:\n• Domain Model: definisce le entit`a principali del sistema, come utenti, videogiochi, carrello, libreria,\nstatistiche e achievement, rappresentando la struttura dei dati.\n• Business Logic: contiene la logica applicativa, gestendo operazioni come la ricerca dei videogiochi,\nl’elaborazione degli acquisti, la gestione delle statistiche di gioco e le funzionalit`a amministrative.\n• ORM (Object-Relational Mapping): utilizzato per mappare gli oggetti del domain model alle tabelle del\ndatabase, semplificando le operazioni di persistenza.\n• JDBC: impiegato per il collegamento al database relazionale PostgreSQL, garantendo un’interazione\nefficiente e sicura con i dati.\nIl database scelto per il progetto `e PostgreSQL. L’interfaccia utente `e stata implementata come una Command\nLine Interface (CLI), offrendo un’interazione semplice e diretta con il sistema.\nPer lo sviluppo, la documentazione e il design, sono stati utilizzati i seguenti strumenti:\n• StarUML: impiegato per la creazione dei diagrammi UML, inclusi i diagrammi degli use case e dei\ndiagrammi di classe, utili per definire la struttura e il comportamento del sistema.\n• Figma: utilizzato per la progettazione dei mockup dell’interfaccia utente, anche se l’implementazione finale\nsi `e concentrata sulla CLI.\n• draw.io: impiegato per la creazione dei mockup.\n• Eclipse IDE: ambiente di sviluppo integrato (IDE) scelto per la scrittura, la gestione e il debug del codice\nsorgente.\n• JUnit 5: utilizzato per l’implementazione dei test.\n1.3\nRelazioni tra i pacchetti\nLe relazioni tra i pacchetti del sistema sono organizzate secondo un’architettura a strati, dove ogni livello intera-\ngisce con quello sottostante per garantire modularit`a e separazione delle responsabilit`a. Di seguito `e descritta la\nrelazione tra i vari componenti:\n• Interfaccia (CLI): L’interfaccia a riga di comando (CLI) rappresenta il punto di contatto con l’utente. Essa\ninvoca i metodi esposti dalla Business Logic per gestire le interazioni tra utente e sistema.\n• Business Logic: Utilizza le entit`a definite nel domain model e si affida all’ORM per le operazioni di\npersistenza, evitando interazioni dirette con il database.\n3\n",
  "5": "Samuele Lattanzi\nIngegneria del Software\n• ORM (Object-Relational Mapping): L’ORM funge da intermediario tra la business logic e il database,\nmappando le entit`a del domain model alle tabelle del database relazionale. Questo strato traduce le opera-\nzioni sui dati (come creazione, lettura, aggiornamento ed eliminazione) in query SQL, senza che la business\nlogic debba gestire direttamente i dettagli del database.\n• JDBC (Java Database Connectivity): JDBC fornisce il collegamento tra l’ORM e il database PostgreSQL.\nAttraverso le API di JDBC, l’ORM invia query SQL al database e riceve i risultati, garantendo un’interazione\nefficiente e sicura con l’RDBMS.\n• RDBMS (PostgreSQL): Il sistema di gestione del database relazionale (RDBMS) PostgreSQL memorizza\ni dati del sistema. `E il livello pi`u basso e risponde esclusivamente alle richieste effettuate tramite JDBC.\n4\n",
  "6": "Samuele Lattanzi\nIngegneria del Software\n2\nDocumentazione\n2.1\nUse Case Diagram\nIn questa sezione vengono presentati use case diagram, che descrivono le interazioni tra gli attori del sistema\n(Utente, Admin) e le funzionalit`a principali dell’applicazione.\nFigura 1: Use Case Diagram - Utente\nFigura 2: Use Case Diagram - Admin\nIl diagramma degli use case, mostrato nella Figura 1, illustra le principali funzionalit`a che riguardano l’utente,\nmentre quello mostrato nella Figura 2 fa riferimento all’admin.\n5\n",
  "7": "Samuele Lattanzi\nIngegneria del Software\n2.2\nUse Case Template\nIn questa sezione vengono presentati i template relativi ad i casi d’uso principali del progetto.\nUse Case 1: Acquistare un videogioco (UC-001)\nLivello\nUser Goal\nDescrizione\nConsentire a un utente autenticato di selezionare videogiochi dal catalogo,\naggiungerli al carrello e completare l’acquisto, aggiornando la libreria e il\nfondo.\nAttori\nUtente\nPreconditions\nL’utente deve essersi autenticato nel sistema e si deve trovare nel menu\nprincipale\nSteps\n1. L’utente seleziona l’opzione per accedere al catalogo (dal menu in\nMock-up 5)\n2. L’utente sceglie tra l’opzione di visualizzazione o di ricerca\n3. L’utente visualizza l’elenco completo di tutti i giochi acquistabili, oppure\nsolo quelli filtrati attraverso la ricerca (Mock-up 6, Test 29)\n4. L’utente seleziona il videogioco che vuole acquistare e lo aggiunge al\ncarrello\n5. L’utente pu`o visualizzare il carrello e costo totale (Mock-up 7)\n6. L’utente esegue l’acquisto dei giochi nel carrello.\nSvolgimenti alternativi\n• 4a. Se l’utente sceglie un gioco che ha gi`a acquistato viene notificato con un\nmessaggio e riprova (Test 30)\n• 6a. Se l’utente accede ad un carrello vuoto riceve un messaggio e torna al\ncatalogo\n• 6b. Se l’utente ha un fondo insufficiente viene notificato e non pu`o\ncompletare l’acquisto (Test 28)\nPostconditions\nIl carrello viene svuotato, i giochi sono spostati nella libreria personale e\nsalvati nel sistema e il fondo viene aggiornato.\nTabella 1: Template che descrive il caso d’uso per l’acquisto di videogiochi da parte di un utente\n6\n",
  "8": "Samuele Lattanzi\nIngegneria del Software\nUse Case 2: Gestire la libreria personale (UC-002)\nLivello\nUser Goal\nDescrizione\nConsente a un utente autenticato di visualizzare, installare, disinstallare,\navviare giochi e consultare statistiche e achievement.\nAttori\nUtente\nPreconditions\nL’utente ha effettuato il login e possiede giochi acquistati\nSteps\n1. L’utente seleziona l’opzione per accedere alla propria libreria di giochi\n(Mock-up 5)\n2. Il sistema mostra i giochi acquistati dall’utente, con la loro descrizione e\nstato di installazione (Mock-up 8)\n3. L’utente seleziona di installare o disinstallare un gioco\n4. Il sistema aggiorna lo stato di installazione o il tempo di gioco associato al\nvideogioco selezionato.\nSvolgimenti alternativi\n• 3a. Se la libreria `e vuota l’utente riceve un messaggio per avvertirlo di non\npoter compiere azioni.\n• 3b. L’utente seleziona l’opzione di avviare un videogioco e giocarlo\n– 3b.1 L’utente seleziona quanto tempo vuole giocare al videogioco.\n– 3b.2 L’utente simula di giocare a un videogioco e viene aggiornato il\ntempo di gioco.\n• 3c. L’utente seleziona l’opzione di visualizzare statistiche e achievement\nrelativi ad un videogioco (Test 32)\n– 3c.1 Il sistema mostra le statistiche associate al gioco.\n– 3c.2 se non ci sono achievement associati ad un gioco il sistema\nmanda un messaggio. (Test 33)\n• 3d. Se l’utente seleziona di installare un gioco gi`a installato o viceversa il\nsistema glielo impedisce e manda un messaggio (Test 31)\nPostconditions\nIl sistema aggiorna lo stato di installazione o il tempo di gioco associato al\nvideogioco selezionato e le modifiche sono salvate nel database\nTabella 2: Template che descrive il caso d’uso per la gestione della libreria e dei giochi contenuti in essa.\nUse Case 3: Gestire il catalogo come amministratore (UC-003)\nLivello\nSummary\nDescrizione\nConsente all’amministratore di aggiungere, modificare, eliminare videogiochi\ne achievement e gestire lo stato gratuito dei videogiochi del catalogo.\nAttori\nAdmin\nPreconditions\nL’amministratore ha effettuato il login con credenziali valide\nSteps\n1. L’admin ha accesso al menu da amministratore (Mock-up 9)\n2. L’admin seleziona azione: aggiungi, modifica, elimina videogioco o\nachievement oppure imposta/rimuovi gratuito (Test 29 e Test 33).\n3. Il sistema esegue l’operazione e mostra la conferma.\nSvolgimenti alternativi\n• 1a. Se le credenziali non sono valide viene mandato un messaggio di errore\n(Test 34)\n• 2a. Se i dati immensi dall’admin durante la creazione o la modifica non\nsono validi riceve messaggio di errore\nPostconditions\nIl catalogo viene aggiornato nel database e le modifiche ai videogiochi e agli\nachievement salvate\n7\n",
  "9": "Samuele Lattanzi\nIngegneria del Software\nTabella 3: Template che descrive il caso d’uso per la gestione delle operazioni CRUD effettuate dall’admin\nUse Case 4: Gestire gli abbonamenti (UC-004)\nLivello\nUser Goal\nDescrizione\nConsente a un utente autenticato di scegliere e attivare un abbonamento (Gold\no Silver), che offre sconti sui giochi e accesso a giochi gratuiti.\nAttori\nUtente\nPreconditions\nL’utente ha effettuato il login con credenziali valide.\nSteps\n1. L’utente seleziona seleziona l’opzione per gestire gli abbonamenti dal\nmenu utente (Mock-up 5)\n2. Il sistema mostra lo stato attuale dell’abbonamento (nessuno, Gold o\nSilver) e chiede che tipo di abbonamento attivare.\n3. L’utente seleziona un’opzione.\n4. Il sistema verifica che il fondo dell’utente sia sufficiente per il costo\ndell’abbonamento.\n5. Il sistema addebita il costo e attiva l’abbonamento\nSvolgimenti alternativi\n• 3a. Se `e gi`a presente un abbonamento attivo l’utente `e notificato con un\nmessaggio.\n• 4a. Se il fondo `e insufficiente Il sistema mostra un errore e propone di\nricaricare il fondo (Test 28).\nPostconditions\nLo stato dell’abbonamento `e aggiornato nel database, i benefici (sconti e\ngiochi gratuiti) sono applicati.\nTabella 4: Template che descrive il caso d’uso per la gestione degli abbonamenti.\n2.3\nMock-Ups\nIn questa sezione vengono riportate delle possibili tabelle di mockup per il progetto.\nFigura 3: Mockup raffigurante un prototipo del menu inziale dell’applicazione\n8\n",
  "10": "Samuele Lattanzi\nIngegneria del Software\nFigura 4: Mockup raffigurante un prototipo del menu di login\nFigura 5: Mockup raffigurante un prototipo della schermata principale per l’utente\nFigura 6: Mockup raffigurante un prototipo della visualizzazione del catalogo di videogiochi\n9\n",
  "11": "Samuele Lattanzi\nIngegneria del Software\nFigura 7: Mockup raffigurante un prototipo della visualizzazione del carrello\nFigura 8: Mockup raffigurante un prototipo della visualizzazione della libreria\nFigura 9: Mockup raffigurante un prototipo del menu dell’admin\n10\n",
  "12": "Samuele Lattanzi\nIngegneria del Software\n2.4\nClass Diagram\nIn questa sezione viene riportato il diagramma di classe del progetto\nFigura 10: Diagramma di Classe, con suddivisione nei pacchetti Domain Model, Business Logic, ORM\n2.5\nER Diagram\nFigura 11: Diagramma ER: Rappresentazione della struttura delle tabelle create dal DBMS\n11\n",
  "13": "Samuele Lattanzi\nIngegneria del Software\n3\nImplementazione\n3.1\nDomain Model\nIn questa sezione viene descritto il Domain Model del sistema, che rappresenta le entit`a principali e le loro inte-\nrazioni all’interno della piattaforma. Le entit`a rappresentate sono: gli utenti, i videogiochi, il carrello, la libreria\npersonale, gli abbonamenti, le statistiche, gli achievement e l’admin. Di seguito viene fornita una descrizione\ndettagliata delle classi principali, con particolare attenzione al loro ruolo, agli attributi e metodi pi`u rilevanti, e alle\nrelazioni con altre classi.\n3.1.1\nUtente\nLa classe Utente modella un utente registrato nel sistema, con attributi che permetto l’autenticazione e la registra-\nzione(username e password e email), l’acquisto di videogiochi e la gestione degli abbonamenti(abbonamentoAttivo\ne fondo). In particolare l’attributo abbonamentoAttivo determina lo stato di un abbonamento valido associa-\nto all’utente, mentre fondo determina il saldo associato all’utente. La classe mette inoltre a disposizione metodi\ngetter e setter per gestire gli attributi.\n3.1.2\nVideogioco\nLa classe Videogioco modella un videogioco disponibile nel catalogo del sistema, con attributi che permettono\nla gestione del catalogo (id, titolo, genere, piattaforma, dataUscita) e l’acquisto di videogiochi\n(prezzo, isGratuito). In particolare, l’attributo prezzo determina il costo del gioco, mentre isGratuito\nindica se il gioco `e accessibile gratuitamente tramite un abbonamento.\n3.1.3\nCarrello\nLa classe Carrello modella il carrello di un utente, con attributi che permettono la selezione di videogiochi per\nl’acquisto (videogiochi, prezzoStrategy) e l’associazione all’utente (idUtente). In particolare, l’at-\ntributo videogiochi contiene la lista dei giochi selezionati, mentre prezzoStrategy implementa il pattern\nStrategy tramite l’interfaccia PrezzoStrategy e le sue implementazioni (GoldAbbonatoPrezzoStrategy,\nSilverAbbonatoPrezzoStrategy, NonAbbonatoPrezzoStrategy). Questo pattern consente di cal-\ncolare dinamicamente il prezzo dei videogiochi in base allo stato dell’abbonamento dell’utente, applicando uno\nsconto del 20% per gli utenti Gold, del 10% per gli utenti Silver, o nessun sconto per gli utenti non abbonati.\npublic interface PrezzoStrategy {\ndouble calculatePrice(Videogioco videogioco, Utente utente);\n}\nSnippet 1: Interfaccia PrezzoStrategy per la gestione dinamica dei prezzi\npublic double getTotale(Utente utente) {\nreturn videogiochi.stream()\n.mapToDouble(videogioco -> prezzoStrategy.calculatePrice(videogioco,\nutente))\n.sum();\n}\nSnippet 2: Metodo per il calcolo del totale nella classe Carrello\nLo snippet 1 definisce l’interfaccia PrezzoStrategy, che specifica il metodo calculatePrice() per cal-\ncolare il prezzo di un videogioco, implementata con la rispettiva logica nelle classi GoldAbbonatoPrezzoStrategy,\nSilverAbbonatoPrezzoStrategy e NonAbbonatoPrezzoStrategy. Lo snippet 2 mostra il metodo getTotale(),\nche somma i prezzi calcolati in base alla strategia di prezzo corrente per tutti i giochi nel carrello. Questi snippet\nevidenziano come il pattern Strategy consenta di adattare dinamicamente il calcolo dei prezzi in base al tipo di\nabbonamento dell’utente, garantendo flessibilit`a e scalabilit`a.\n3.1.4\nLibreria\nLa classe Libreria modella la collezione di videogiochi acquistati da un utente, con attributi che permettono la\ngestione dei giochi posseduti (videogiochiAcquistati, statoInstallazione) e l’associazione all’u-\ntente (idUtente). In particolare, l’attributo videogiochiAcquistati contiene i giochi acquistati, mentre\n12\n",
  "14": "Samuele Lattanzi\nIngegneria del Software\nstatoInstallazione traccia lo stato di installazione di ciascun gioco. La classe mette a disposizione metodi\ngetter e setter per gestire gli attributi.\n3.1.5\nAbbonamento\nLa classe Abbonamento modella un abbonamento sottoscritto da un utente, con attributi che permettono la\ngestione dello stato e della durata dell’abbonamento (stato, tipo, dataInizio, dataFine) e l’associazione\nall’utente (idUtente). In particolare, l’attributo stato indica se l’abbonamento `e attivo, mentre tipo specifica\nse `e Gold o Silver, influenzando sconti e benefici. La classe mette a disposizione metodi getter per gestire gli\nattributi.\n3.1.6\nStatisticheVideogioco\nLa classe StatisticheVideogioco modella le statistiche di gioco di un utente per un videogioco specifico,\ncon attributi che permettono il tracciamento del tempo di gioco e l’associazione all’utente e al videogioco. In\nparticolare, l’attributo tempoGioco registra il tempo trascorso giocando, mentre idUtente e idVideogioco\ncollegano le statistiche al rispettivo utente e gioco. La classe mette a disposizione metodi getter e setter per gestire\ngli attributi.\n3.1.7\nAchievement\nLa classe Achievement modella un obiettivo ottenibile in un videogioco, con attributi che permettono la descri-\nzione dell’obiettivo (nome, descrizione, tempoRichiesto) e l’associazione al videogioco (idVideogioco).\nIn particolare, l’attributo tempoRichiesto indica il tempo di gioco necessario per sbloccare l’obiettivo, mentre\nnome e descrizione ne definiscono le caratteristiche. La classe mette a disposizione metodi getter e setter per\ngestire gli attributi.\n3.1.8\nAdmin\nLa classe Admin modella un amministratore del sistema, con attributi che permettono l’autenticazione e la ge-\nstione del sistema (username, password) e l’identificazione (id). In particolare, l’attributo username e\npassword garantiscono l’accesso sicuro per le operazioni amministrative, come la gestione del catalogo. La\nclasse mette a disposizione metodi getter e setter per gestire gli attributi.\n3.2\nBusiness Logic\nIn questa sezione viene descritto il pacchetto Business Logic del sistema, in cui sono definite le funzio-\nnalit`a operative della piattaforma per la vendita di videogiochi.\nLa Business Logic coordina le interazio-\nni tra le entit`a del Domain Model (es. Utente, Videogioco, Carrello, Libreria, Abbonamento,\nStatisticheVideogioco, Achievement, Admin) e il database tramite i Data Access Object (DAO). Le\nclassi controller implementano le operazioni definite negli use case (si vedano le Tabelle 1, 2, 3, 4), come re-\ngistrazione e autenticazione degli utenti, gestione del carrello e degli acquisti, attivazione degli abbonamenti,\nmonitoraggio delle statistiche di gioco e gestione amministrativa del catalogo.\nDi seguito, vengono descritte le classi principali della Business Logic, con particolare attenzione al loro ruolo,\nalle interazioni con i DAO e alle funzionalit`a chiave di ciascuna.\n3.2.1\nUtenteController\nLa classe UtenteController gestisce le operazioni relative agli utenti, come registrazione, autenticazione,\nattivazione degli abbonamenti e ricarica del saldo, con attributi che permettono l’interazione con il database\n(utenteDAO, abbonamentoDAO). In particolare, l’attributo utenteDAO gestisce la persistenza degli utenti,\nmentre abbonamentoDAO gestisce gli abbonamenti.\npublic void attivaAbbonamento(Utente utente, Abbonamento abbonamento) {\ndouble costoAbbonamento = getCostoAbbonamento(abbonamento.getTipo());\nif (utente.getFondo() >= costoAbbonamento) {\nutente.setFondo(utente.getFondo() - costoAbbonamento);\nutente.setAbbonamentoAttivo(true);\nabbonamentoDAO.save(abbonamento);\nutenteDAO.update(utente);\n} else {\n13\n",
  "15": "Samuele Lattanzi\nIngegneria del Software\nthrow new IllegalStateException(\"Fondo insufficiente per attivare l’\nabbonamento \" + abbonamento.getTipo());\n}\n}\nSnippet 3: Metodo per l’attivazione di un abbonamento nella classe UtenteController\npublic void ricaricaFondo(Utente utente, double importo) {\nif (importo <= 0) {\nthrow new IllegalArgumentException(\"L’importo deve essere positivo\");\n}\nutente.setFondo(utente.getFondo() + importo);\nutenteDAO.update(utente);\n}\nSnippet 4: Metodo per la ricarica del saldo nella classe UtenteController\nLo snippet di codice 3 mostra il metodo attivaAbbonamento(), che implementa l’attivazione di un abbo-\nnamento: verifica il saldo disponibile, addebita il costo, aggiorna lo stato dell’abbonamento e persiste i dati tramite\ni DAO. Lo snippet 4, invece mostra il metodo ricaricaFondo(): verifica se l’importo `e valido, aggiorna il\nfondo in maniera oppurtuna, salva le modifiche tramite il DAO.\n3.2.2\nCarrelloController\nLa classe CarrelloController gestisce le operazioni relative al carrello di un utente, come l’aggiunta e la\nrimozione di videogiochi, l’esecuzione degli acquisti e l’aggiornamento della libreria, con attributi che permettono\nl’interazione con il database (carrelloDAO, utenteDAO, abbonamentoDAO, libreriaDAO) e la notifica\ndi eventi (observers). Questa svolge il ruolo di Subject, in quanto notifica il proprio cambiamento di Stato alla\nlibreria dell’utente nel momento in cui viene completato con successo un acquisto e si deve aggiornare la libreria.\nLa classe utilizza il pattern Strategy tramite PrezzoStrategy per calcolare i prezzi in base agli abbonamenti,\ncome descritto nel Domain Model.\npublic boolean eseguiAcquisto(Carrello carrello) {\nUtente utente = utenteDAO.findById(carrello.getIdUtente());\nif (utente == null) {\nthrow new IllegalStateException(\"Utente non trovato.\");\n}\ndouble totale = carrello.getTotale(utente);\nLibreria libreria = libreriaDAO.findByUtenteId(utente.getId());\nif (libreria != null) {\nfor (Videogioco v : carrello.getVideogiochi()) {\nif (libreria.getVideogiochiAcquistati().contains(v)) {\nthrow new IllegalArgumentException(\"Il gioco \" + v.getTitolo() + \" e\n’ gia’ presente nella tua libreria.\");\n}\n}\n}\nif (utente.getFondo() >= totale) {\nutente.setFondo(utente.getFondo() - totale);\nutenteDAO.update(utente);\ntrasferisciInLibreria(utente, carrello.getVideogiochi());\nnotificaAcquistoCompletato(utente, carrello);\ncarrelloDAO.delete(carrello.getId());\nreturn true;\n} else {\nthrow new IllegalStateException(\"Fondo insufficiente per completare l’\nacquisto.\");\n}\n}\nSnippet 5: Metodo per l’esecuzione di un acquisto nella classe CarrelloController\nprivate void trasferisciInLibreria(Utente utente, List<Videogioco> videogiochi) {\nLibreria libreria = libreriaDAO.findByUtenteId(utente.getId());\n14\n",
  "16": "Samuele Lattanzi\nIngegneria del Software\nif (libreria == null) {\nSystem.out.println(\"Creazione nuova libreria per utente: \" + utente.\ngetId());\nlibreria = new Libreria(0, utente.getId());\nfor (Videogioco v : videogiochi) {\nSystem.out.println(\"Aggiungo videogioco alla nuova libreria: \" + v.\ngetTitolo() + \" (ID: \" + v.getId() + \")\");\nlibreria.addVideogioco(v);\nlibreria.setVideogiocoInstallato(v, false);\n}\nlibreriaDAO.save(libreria);\n} else {\nSystem.out.println(\"Aggiornamento libreria esistente: libreria_id=\" +\nlibreria.getId());\nfor (Videogioco v : videogiochi) {\nif (!libreria.getVideogiochiAcquistati().contains(v)) {\nSystem.out.println(\"Aggiungo videogioco alla libreria: \" + v.\ngetTitolo() + \" (ID: \" + v.getId() + \")\");\nlibreria.addVideogioco(v);\nlibreria.setVideogiocoInstallato(v, false);\n} else {\nSystem.out.println(\"Videogioco gia’ presente nella libreria: \" +\nv.getTitolo() + \" (ID: \" + v.getId() + \")\");\n}\n}\nlibreriaDAO.update(libreria);\n}\n}\nSnippet 6: Metodo per trasferire i videogiochi acquistati dal carrello alla libreria nella classe CarrelloController\npublic void notificaAcquistoCompletato(Utente utente, Carrello carrello) {\nfor (Observer observer : observers) {\nobserver.onAcquistoCompletato(utente, carrello);\n}\n}\nSnippet 7: Metodo per la notifica alla libreria dell’acquisto di giochi dal carrello nella classe CarrelloController\nprivate void setPrezzoStrategy(Carrello carrello, Utente utente) {\nAbbonamento abbonamento = abbonamentoDAO.findByUtenteId(utente.getId());\nif (abbonamento != null && abbonamento.isAttivo()) {\nswitch (abbonamento.getTipo()) {\ncase \"Silver\":\ncarrello.setPrezzoStrategy(new SilverAbbonatoPrezzoStrategy());\nbreak;\ncase \"Gold\":\ncarrello.setPrezzoStrategy(new GoldAbbonatoPrezzoStrategy());\nbreak;\ndefault:\ncarrello.setPrezzoStrategy(new NonAbbonatoPrezzoStrategy());\n}\n} else {\ncarrello.setPrezzoStrategy(new NonAbbonatoPrezzoStrategy());\n}\n}\nSnippet 8: Metodo per impostare la strategia di prezzo nella classe CarrelloController\nIl Listato 5 mostra il metodo eseguiAcquisto(), che implementa l’acquisto dei videogiochi preceden-\ntemente inseriti nel carrello, verificando l’utente, il saldo e la libreria, aggiornando il fondo, trasferendo i gio-\nchi e notificando gli observer tramite il pattern Observer e al metodo notificaAcquistoCompletato()\n( 7) che implementa la notifica a tutti gli observer connessi al carrello.\nIl Listato 6 mostra il metodo\ntrasferisciInLibreria(), che sposta i videogiochi acquistati dal carrello di un utente alla libreria ad\n15\n",
  "17": "Samuele Lattanzi\nIngegneria del Software\nesso associato. Il Listato 8 mostra il metodo setPrezzoStrategy(), che configura dinamicamente la strate-\ngia di prezzo in base all’abbonamento dell’utente. Questi metodi evidenziano il ruolo centrale della classe nella\ngestione degli acquisti, integrando il pattern Strategy per i prezzi e il pattern Observer per le notifiche.\n3.2.3\nLibreriaController\nLa classe LibreriaController gestisce le operazioni relative alla libreria di un utente, come il caricamento\ndella libreria, l’installazione e la disinstallazione di videogiochi, l’avvio dei giochi e l’accesso a statistiche e achie-\nvement, con attributi che permettono l’interazione con il database (libreriaDAO) e la gestione delle statistiche\n(statisticheController). La classe implementa il pattern Observer per ricevere notifiche di acquisto da\nCarrelloController. La classe supporta le funzionalit`a di gestione della libreria e delle attivit`a di gioco,\ngarantendo l’autorizzazione dell’utente e l’aggiornamento dello stato dei giochi.\npublic void installaVideogioco(Utente utente, Videogioco videogioco) {\nif (utente.getId() == libreria.getIdUtente()) {\nif (libreria.getVideogiochiAcquistati().contains(videogioco)) {\nif (!libreria.isVideogiocoInstallato(videogioco)) {\nSystem.out.println(\"Installazione del videogioco: \" + videogioco.\ngetTitolo());\nlibreria.setVideogiocoInstallato(videogioco, true);\nlibreriaDAO.update(libreria);\n} else {\nthrow new IllegalStateException(\"Videogioco gia’ installato\");\n}\n} else {\nthrow new IllegalArgumentException(\"Videogioco non acquistato\");\n}\n} else {\nthrow new SecurityException(\"Utente non autorizzato\");\n}\n}\nSnippet 9: Metodo per installare un videogioco nella classe LibreriaController\npublic void avviaVideogioco(Utente utente, Videogioco videogioco, int tempo) {\nif (utente.getId() == libreria.getIdUtente()) {\nif (libreria.getVideogiochiAcquistati().contains(videogioco)) {\nif (libreria.isVideogiocoInstallato(videogioco)) {\nSystem.out.println(\"Avvio del videogioco: \" + videogioco.getTitolo()\n+ \" per \" + tempo + \" secondi\");\nstatisticheController.aggiornaTempoGioco(utente, videogioco, tempo);\n} else {\nthrow new IllegalStateException(\"Videogioco non installato\");\n}\n} else {\nthrow new IllegalArgumentException(\"Videogioco non acquistato\");\n}\n} else {\nthrow new SecurityException(\"Utente non autorizzato\");\n}\n}\nSnippet 10: Metodo per avviare un videogioco nella classe LibreriaController\n@Override\npublic void onAcquistoCompletato(Utente utente, Carrello carrello) {\nif (utente.getId() == libreria.getIdUtente()) {\nString titoli = carrello.getVideogiochi().stream()\n.map(Videogioco::getTitolo)\n.collect(Collectors.joining(\", \"));\nSystem.out.println(\"Notifica: Videogiochi acquistati e aggiunti alla\nlibreria di \" + utente.getUsername() + \": \" + titoli);\n} else {\nthrow new SecurityException(\"Utente non autorizzato\");\n16\n",
  "18": "Samuele Lattanzi\nIngegneria del Software\n}\n}\nSnippet 11: Metodo per ricevere notifiche di acquisto nella classe LibreriaController\nLo snippet 9 mostra il metodo installaVideogioco(), che installa un videogioco acquistato, ve-\nrificando l’autorizzazione dell’utente e lo stato del gioco, e aggiorna la libreria.\nLo snippet 10 mostra il\nmetodo avviaVideogioco(), che avvia un videogioco installato, aggiornando il tempo di gioco tramite\nstatisticheController. Lo snippet 11 mostra il metodo onAcquistoCompletato(), che implemen-\nta il metodo update, tipico del pattern Observer, e riceve notifiche di acquisto, aggiornando la libreria con i nuovi\ngiochi.\n3.2.4\nCatalogoController\nLa classe CatalogoController mette a disposizione le operazioni relative al catalogo e permette sia la ge-\nstione da parte dell’admin dei videogiochi del catalogo( aggiunta, modifica, eliminazione) sia la ricerca dei giochi,\ncon attributi che permettono l’interazione con il database (videogiocoDAO, adminDAO).\npublic void aggiungiVideogioco(Videogioco videogioco, Admin admin) {\nif (adminDAO.findById(admin.getId()) == null) {\nthrow new SecurityException(\"Admin non autenticato\");\n}\nif (videogiocoDAO.findById(videogioco.getId()) == null) {\nvideogiocoDAO.save(videogioco);\n} else {\nthrow new IllegalArgumentException(\"Videogioco gia’ esistente\");\n}\n}\nSnippet 12: Metodo per aggiungere un videogioco al catalogo nella classe CatalogoController\npublic List<Videogioco> cercaVideogiochi(String genere, String piattaforma,\nLocalDate data) {\nreturn videogiocoDAO.findByCriteria(genere, piattaforma, data);\n}\nSnippet 13: Metodo per cercare videogiochi nel catalogo nella classe CatalogoController\npublic List<Videogioco> getVideogiochiPerUtente(Utente utente) {\nList<Videogioco> videogiochi = videogiocoDAO.findByCriteria(null, null, null);\nif (utente != null && utente.isAbbonamentoAttivo()) {\nAbbonamento abbonamento = new AbbonamentoDAO().findByUtenteId(utente.getId()\n);\nPrezzoStrategy prezzoStrategy = switch (abbonamento != null ? abbonamento.\ngetTipo() : \"Nessuno\") {\ncase \"Silver\" -> new SilverAbbonatoPrezzoStrategy();\ncase \"Gold\" -> new GoldAbbonatoPrezzoStrategy();\ndefault -> new NonAbbonatoPrezzoStrategy();\n};\nreturn videogiochi.stream()\n.map(v -> new Videogioco(\nv.getId(),\nv.getTitolo(),\nv.getGenere(),\nv.getPiattaforma(),\nprezzoStrategy.calculatePrice(v, utente),\nv.getDataUscita(),\nv.isGratuito()\n))\n.collect(Collectors.toList());\n}\nreturn videogiochi;\n}\nSnippet 14: Metodo per ottenere videogiochi personalizzati per un utente nella classe CatalogoController\n17\n",
  "19": "Samuele Lattanzi\nIngegneria del Software\nLo snippet 12 mostra il metodo\naggiungiVideogioco(), che consente a un amministratore autenticato di aggiungere un videogioco al ca-\ntalogo, verificando l’unicit`a. Lo snippet 13 mostra il metodo cercaVideogiochi(), che restituisce una lista\ndi videogiochi filtrata per genere, piattaforma o data, supportando la ricerca degli utenti. Lo snippet 14 mostra il\nmetodo getVideogiochiPerUtente(), che restituisce il catalogo con prezzi personalizzati in base all’ab-\nbonamento dell’utente. Questi metodi evidenziano il ruolo della classe nella gestione amministrativa e nell’accesso\npersonalizzato al catalogo.\n3.2.5\nStatisticheController\nLa classe StatisticheController gestisce le statistiche di gioco e gli achievement degli utenti, come l’ag-\ngiornamento del tempo di gioco e la verifica degli obiettivi sbloccati, con attributi che permettono l’interazione\ncon il database (statisticheDAO, achievementDAO). La classe supporta le funzionalit`a di monitoraggio\ndelle attivit`a di gioco, integrandosi con LibreriaController per aggiornare il tempo di gioco e sbloccare gli\nachievement.\npublic void aggiornaTempoGioco(Utente utente, Videogioco videogioco, int tempo) {\nStatisticheVideogioco statistiche = statisticheDAO.findByUtenteAndVideogioco(\nutente.getId(), videogioco.getId());\nif (statistiche == null) {\nstatistiche = new StatisticheVideogioco(0, utente.getId(), videogioco.getId\n(), tempo);\n} else {\nstatistiche.setTempoGioco(statistiche.getTempoGioco() + tempo);\n}\nstatisticheDAO.save(statistiche);\nverificaAchievement(utente, videogioco, statistiche.getTempoGioco());\n}\nSnippet 15: Metodo per aggiornare il tempo di gioco nella classe StatisticheController\nprivate void verificaAchievement(Utente utente, Videogioco videogioco, int\ntempoTotal) {\nList<Achievement> achievements = achievementDAO.findByVideogioco(videogioco.\ngetId());\nList<Achievement> utenteAchievements = achievementDAO.getUtenteAchievements(\nutente.getId(), videogioco.getId());\nfor (Achievement achievement : achievements) {\nboolean isAlreadyAchieved = utenteAchievements.stream()\n.anyMatch(a -> a.getId() == achievement.getId());\nif (!isAlreadyAchieved && tempoTotal >= achievement.getTempoRichiesto()) {\nachievementDAO.saveUtenteAchievement(utente.getId(), achievement.getId()\n);\n}\n}\n}\nSnippet 16: Metodo per verificare gli achievement nella classe StatisticheController\nLo snippet 15 mostra il metodo aggiornaTempoGioco(), che aggiorna il tempo di gioco di un utente per\nun videogioco, creando una nuova statistica se necessario e verificando gli achievement. Lo snippet 16 mostra il\nmetodo verificaAchievement(), che controlla se il tempo di gioco soddisfa i requisiti per sbloccare nuovi\nachievement, salvandoli nel database.\n3.2.6\nAchievementController\nLa classe AchievementController gestisce le operazioni relative agli achievement dei videogiochi, come\nl’aggiunta, la modifica, l’eliminazione e il recupero degli achievement da parte dell’admin.\npublic void aggiungiAchievement(int idVideogioco, String nome, String descrizione,\nint tempoRichiesto, Admin admin) {\nif (adminDAO.findById(admin.getId()) == null) {\nthrow new SecurityException(\"Admin non autenticato\");\n}\n18\n",
  "20": "Samuele Lattanzi\nIngegneria del Software\nAchievement achievement = new Achievement(0, idVideogioco, nome, descrizione,\ntempoRichiesto);\nachievementDAO.save(achievement);\n}\nSnippet 17: Metodo per aggiungere un achievement nella classe AchievementController\nLo snippet 17 mostra il metodo aggiungiAchievement(), che consente a un amministratore autenticato\ndi aggiungere un nuovo achievement per un videogioco, persitendolo nel database.\n3.2.7\nAdminController\nLa classe AdminController gestisce le operazioni relative agli amministratori, come registrazione, autentica-\nzione e aggiornamento della password, con un attributo che permette l’interazione con il database (adminDAO).\npublic boolean registraAdmin(Admin admin) {\nif (adminDAO.findByUsername(admin.getUsername()) != null) {\nreturn false;\n}\nadminDAO.save(admin);\nreturn true;\n}\nSnippet 18: Metodo per registrare un amministratore nella classe AdminController\nLo snippet 18 mostra il metodo registraAdmin(), che registra un nuovo amministratore, verificando\nl’unicit`a dell’username e persitendolo nel database.\n3.3\nORM (Object-Relational Mapping)\nQuesta sezione descrive il livello di accesso ai dati del sistema, implementato tramite Object-Relational Map-\nping (ORM) per gestire la persistenza delle entit`a del Domain Model (Utente, Videogioco, Carrello,\nLibreria, Abbonamento, StatisticheVideogioco, Achievement, Admin) su un database Postgre-\nSQL. La classe DatabaseConnection fornisce una connessione Singleton al DBMS, mentre le classi DAO\n(Data Access Object) gestiscono le operazioni CRUD (Create, Read, Update, Delete) per ogni entit`a.\n3.3.1\nDatabaseConnection\nLa classe DatabaseConnection implementa il pattern Singleton per fornire un’unica istanza di connessione al\ndatabase PostgreSQL, utilizzando le credenziali definite (URL, username, password). L’attributo instance ga-\nrantisce l’unicit`a della connessione, mentre il metodo getConnection() restituisce un oggetto Connection\nper le operazioni dei DAO.\npublic Connection getConnection() throws SQLException {\nreturn DriverManager.getConnection(URL, USER, PASSWORD);\n}\nSnippet 19: Metodo per ottenere la connessione al database nella classe DatabaseConnection\nLo snippet 19 mostra il metodo getConnection(), che stabilisce la connessione al database PostgreSQL,\nutilizzata da tutti i DAO per eseguire query.\n3.3.2\nUtenteDAO\nLa classe UtenteDAO gestisce la persistenza degli oggetti Utente, supportando operazioni CRUD per registra-\nzione, autenticazione e aggiornamento del profilo. L’attributo connection consente l’interazione con il database\ntramite DatabaseConnection.\npublic Utente save(Utente utente) {\nString sql = \"INSERT INTO utenti (username, password, email, abbonamento_attivo,\nfondo) VALUES (?, ?, ?, ?, ?) RETURNING id\";\ntry (PreparedStatement stmt = connection.prepareStatement(sql)) {\nstmt.setString(1, utente.getUsername());\nstmt.setString(2, utente.getPassword());\nstmt.setString(3, utente.getEmail());\n19\n",
  "21": "Samuele Lattanzi\nIngegneria del Software\nstmt.setBoolean(4, utente.isAbbonamentoAttivo());\nstmt.setDouble(5, utente.getFondo());\nResultSet rs = stmt.executeQuery();\nif (rs.next()) {\nint generatedId = rs.getInt(\"id\");\nreturn new Utente(\ngeneratedId,\nutente.getUsername(),\nutente.getPassword(),\nutente.getEmail(),\nutente.isAbbonamentoAttivo(),\nutente.getFondo()\n);\n}\nthrow new SQLException(\"Inserimento fallito, nessun ID generato.\");\n} catch (SQLException e) {\nthrow new RuntimeException(\"Errore durante il salvataggio dell’utente\", e);\n}\n}\nSnippet 20: Metodo per salvare un utente nella classe UtenteDAO\nLo snippet 20 mostra il metodo save(), che inserisce un nuovo utente nel database, restituendo un oggetto\nUtente con l’ID generato, supportando la registrazione. Altri metodi includono update() per aggiornare i dati\nutente, findById() e findByUsername() per il recupero.\n3.3.3\nVideogiocoDAO\nLa classe VideogiocoDAO gestisce la persistenza degli oggetti Videogioco, supportando operazioni\nCRUD per la gestione del catalogo. L’attributo connection consente l’interazione con il database tramite\nDatabaseConnection.\npublic List<Videogioco> findByCriteria(String genere, String piattaforma, LocalDate\ndata) {\nStringBuilder sql = new StringBuilder(\"SELECT * FROM videogiochi WHERE 1=1\");\nList<Object> params = new ArrayList<>();\nif (genere != null) {\nsql.append(\" AND genere = ?\");\nparams.add(genere);\n}\nif (piattaforma != null) {\nsql.append(\" AND piattaforma = ?\");\nparams.add(piattaforma);\n}\nif (data != null) {\nsql.append(\" AND data_uscita = ?\");\nparams.add(Date.valueOf(data));\n}\ntry (PreparedStatement stmt = connection.prepareStatement(sql.toString())) {\nfor (int i = 0; i < params.size(); i++) {\nstmt.setObject(i + 1, params.get(i));\n}\ntry (ResultSet rs = stmt.executeQuery()) {\nList<Videogioco> videogiochi = new ArrayList<>();\nwhile (rs.next()) {\nvideogiochi.add(new Videogioco(\nrs.getInt(\"id\"),\nrs.getString(\"titolo\"),\nrs.getString(\"genere\"),\nrs.getString(\"piattaforma\"),\nrs.getDouble(\"prezzo\"),\nrs.getDate(\"data_uscita\") != null ? rs.getDate(\"data_uscita\").\ntoLocalDate() : null,\nrs.getBoolean(\"is_gratuito\")\n20\n",
  "22": "Samuele Lattanzi\nIngegneria del Software\n));\n}\nreturn videogiochi;\n}\n} catch (SQLException e) {\nthrow new RuntimeException(\"Errore durante la ricerca dei videogiochi\", e);\n}\n}\nSnippet 21: Metodo per cercare videogiochi nella classe VideogiocoDAO\nLo snippet 21 mostra il metodo findByCriteria(), che recupera videogiochi filtrati per genere, piatta-\nforma o data, supportando la ricerca nel catalogo. Altri metodi includono save() per aggiungere videogiochi,\nupdate() per modificarli e delete() per eliminarli.\n3.3.4\nCarrelloDAO\nLa classe CarrelloDAO gestisce la persistenza degli oggetti Carrello, supportando operazioni CRUD\nper la gestione del carrello utente.\nL’attributo connection consente l’interazione con il database tramite\nDatabaseConnection.\npublic void save(Carrello carrello) {\nString sql = \"INSERT INTO carrelli (id, utente_id) VALUES (?, ?) ON CONFLICT (id\n) DO UPDATE SET utente_id = EXCLUDED.utente_id\";\ntry (PreparedStatement stmt = connection.prepareStatement(sql)) {\nstmt.setInt(1, carrello.getId());\nstmt.setInt(2, carrello.getIdUtente());\nstmt.executeUpdate();\nsql = \"DELETE FROM carrello_videogiochi WHERE carrello_id = ?\";\ntry (PreparedStatement deleteStmt = connection.prepareStatement(sql)) {\ndeleteStmt.setInt(1, carrello.getId());\ndeleteStmt.executeUpdate();\n}\nfor (Videogioco videogioco : carrello.getVideogiochi()) {\nsql = \"INSERT INTO carrello_videogiochi (carrello_id, videogioco_id)\nVALUES (?, ?)\";\ntry (PreparedStatement videoStmt = connection.prepareStatement(sql)) {\nvideoStmt.setInt(1, carrello.getId());\nvideoStmt.setInt(2, videogioco.getId());\nvideoStmt.executeUpdate();\n}\n}\n} catch (SQLException e) {\nthrow new RuntimeException(\"Errore durante il salvataggio del carrello\", e);\n}\n}\nSnippet 22: Metodo per salvare un carrello nella classe CarrelloDAO\nLo snippet 22 mostra il metodo save(), che salva o aggiorna un carrello e i suoi videogiochi associati, ge-\nstendo la relazione nella tabella carrello videogiochi. Altri metodi includono update() per aggiornare\nil carrello, findByUtenteId() per recuperarlo e delete() per eliminarlo.\n3.3.5\nLibreriaDAO\nLa classe LibreriaDAO gestisce la persistenza degli oggetti Libreria, supportando operazioni CRUD per la\ngestione dei videogiochi acquistati e installati. L’attributo connection consente l’interazione con il database\ntramite DatabaseConnection.\npublic void save(Libreria libreria) {\nString insertLibreria = \"INSERT INTO librerie (utente_id) VALUES (?) RETURNING\nid\";\ntry (PreparedStatement stmt = connection.prepareStatement(insertLibreria)) {\nstmt.setInt(1, libreria.getIdUtente());\ntry (ResultSet rs = stmt.executeQuery()) {\n21\n",
  "23": "Samuele Lattanzi\nIngegneria del Software\nif (rs.next()) {\nlibreria.setId(rs.getInt(\"id\"));\n}\n}\nString insertVideogioco = \"INSERT INTO libreria_videogiochi (libreria_id,\nvideogioco_id, installato) VALUES (?, ?, ?) \" +\n\"ON CONFLICT (libreria_id, videogioco_id) DO UPDATE SET installato =\nEXCLUDED.installato\";\ntry (PreparedStatement videoStmt = connection.prepareStatement(\ninsertVideogioco)) {\nfor (Videogioco v : libreria.getVideogiochiAcquistati()) {\nvideoStmt.setInt(1, libreria.getId());\nvideoStmt.setInt(2, v.getId());\nvideoStmt.setBoolean(3, libreria.isVideogiocoInstallato(v));\nvideoStmt.addBatch();\n}\nvideoStmt.executeBatch();\n}\n} catch (SQLException e) {\nthrow new RuntimeException(\"Errore durante il salvataggio della libreria\", e\n);\n}\n}\nSnippet 23: Metodo per salvare una libreria nella classe LibreriaDAO\nLo snippet 23 mostra il metodo save(), che salva una libreria e i suoi videogiochi associati, gestendo lo\nstato di installazione. Altri metodi includono findByUtenteId() per recuperare la libreria e update() per\nmodificarla.\n3.3.6\nAbbonamentoDAO\nLa classe AbbonamentoDAO gestisce la persistenza degli oggetti Abbonamento, supportando operazioni CRUD\nper la gestione degli abbonamenti utente. L’attributo connection consente l’interazione con il database tramite\nDatabaseConnection.\npublic void save(Abbonamento abbonamento) {\nString sql = \"\"\"\nINSERT INTO abbonamenti (id, utente_id, data_inizio, data_fine, stato, tipo)\nVALUES (?, ?, ?, ?, ?, ?)\nON CONFLICT (id) DO UPDATE\nSET utente_id = EXCLUDED.utente_id,\ndata_inizio = EXCLUDED.data_inizio,\ndata_fine = EXCLUDED.data_fine,\nstato = EXCLUDED.stato,\ntipo = EXCLUDED.tipo\n\"\"\";\ntry (PreparedStatement stmt = connection.prepareStatement(sql)) {\nstmt.setInt(1, abbonamento.getId());\nstmt.setInt(2, abbonamento.getIdUtente());\nstmt.setDate(3, Date.valueOf(abbonamento.getDataInizio()));\nstmt.setDate(4, Date.valueOf(abbonamento.getDataFine()));\nstmt.setString(5, abbonamento.getStato());\nstmt.setString(6, abbonamento.getTipo());\nstmt.executeUpdate();\n} catch (SQLException e) {\nthrow new RuntimeException(\"Errore durante il salvataggio dell’abbonamento\",\ne);\n}\n}\nSnippet 24: Metodo per salvare un abbonamento nella classe AbbonamentoDAO\nLo snippet 24 mostra il metodo save(), che salva o aggiorna un abbonamento, gestendo i dati relativi a stato\ne tipo. Altri metodi includono findByUtenteId() per recuperare l’abbonamento.\n22\n",
  "24": "Samuele Lattanzi\nIngegneria del Software\n3.3.7\nStatisticheVideogiocoDAO\nLa classe StatisticheVideogiocoDAO gestisce la persistenza degli oggetti StatisticheVideogioco,\nsupportando operazioni CRUD per il monitoraggio del tempo di gioco.\nL’attributo connection consente\nl’interazione con il database tramite DatabaseConnection.\npublic void save(StatisticheVideogioco statistiche) {\nString sql = \"INSERT INTO statistiche_videogiochi (id_utente, id_videogioco,\ntempo_gioco) VALUES (?, ?, ?) \" +\n\"ON CONFLICT (id_utente, id_videogioco) DO UPDATE SET tempo_gioco =\nEXCLUDED.tempo_gioco\";\ntry (PreparedStatement stmt = connection.prepareStatement(sql)) {\nstmt.setInt(1, statistiche.getIdUtente());\nstmt.setInt(2, statistiche.getIdVideogioco());\nstmt.setInt(3, statistiche.getTempoGioco());\nstmt.executeUpdate();\n} catch (SQLException e) {\nthrow new RuntimeException(\"Errore nel salvataggio delle statistiche\", e);\n}\n}\nSnippet 25: Metodo per salvare statistiche di gioco nella classe StatisticheVideogiocoDAO\nLo snippet 25 mostra il metodo save(), che salva o aggiorna le statistiche di gioco, gestendo il tempo di gioco.\nAltri metodi includono findByUtenteAndVideogioco() per il recupero e delete() per l’eliminazione.\n3.3.8\nAchievementDAO\nLa classe AchievementDAO gestisce la persistenza degli oggetti Achievement, supportando operazioni CRUD\nper la gestione degli achievement dei videogiochi e il loro assegnamento agli utenti. L’attributo connection\nconsente l’interazione con il database tramite DatabaseConnection.\npublic List<Achievement> getUtenteAchievements(int idUtente, int idVideogioco) {\nList<Achievement> achievements = new ArrayList<>();\nString sql = \"\"\"\nSELECT a.*\nFROM achievement a\nJOIN utente_achievement ua ON a.id = ua.id_achievement\nWHERE ua.id_utente = ? AND a.id_videogioco = ?\n\"\"\";\ntry (PreparedStatement stmt = connection.prepareStatement(sql)) {\nstmt.setInt(1, idUtente);\nstmt.setInt(2, idVideogioco);\ntry (ResultSet rs = stmt.executeQuery()) {\nwhile (rs.next()) {\nachievements.add(new Achievement(\nrs.getInt(\"id\"),\nrs.getInt(\"id_videogioco\"),\nrs.getString(\"nome\"),\nrs.getString(\"descrizione\"),\nrs.getInt(\"tempo_richiesto\")\n));\n}\n}\n} catch (SQLException e) {\nthrow new RuntimeException(\"Errore nel recupero degli achievement utente\", e\n);\n}\nreturn achievements;\n}\nSnippet 26: Metodo per recuperare gli achievement di un utente nella classe AchievementDAO\nLo snippet 26 mostra il metodo getUtenteAchievements(), che recupera gli achievement sblocca-\nti da un utente per un videogioco, utilizzando una join con la tabella utente achievement. Altri metodi\n23\n",
  "25": "Samuele Lattanzi\nIngegneria del Software\nincludono save(), findByVideogioco(), saveUtenteAchievement() e delete() per gestione e\nassegnamento.\n3.3.9\nAdminDAO\nLa classe AdminDAO gestisce la persistenza degli oggetti Admin, supportando operazioni CRUD per la\ngestione degli amministratori.\nL’attributo connection consente l’interazione con il database tramite\nDatabaseConnection.\npublic void save(Admin admin) {\nString sql = \"INSERT INTO admins (username, password) VALUES (?, ?) RETURNING id\n\";\ntry (PreparedStatement stmt = connection.prepareStatement(sql)) {\nstmt.setString(1, admin.getUsername());\nstmt.setString(2, admin.getPassword());\ntry (ResultSet rs = stmt.executeQuery()) {\nif (rs.next()) {\nadmin.setId(rs.getInt(\"id\"));\n}\n}\n} catch (SQLException e) {\nthrow new RuntimeException(\"Errore nel salvataggio dell’admin\", e);\n}\n}\nSnippet 27: Metodo per salvare un amministratore nella classe AdminDAO\nLo snippet 27 mostra il metodo save(), che salva un amministratore e imposta l’ID generato grazie al setter\ndella classe Admin. Altri metodi includono findById(), findByUsername(), update() e delete()\nper gestione e autenticazione.\n3.4\nDatabase\nIl database utilizzato per il progetto `e implementato in PostgreSQL e interfacciato tramite oggetti DAO, che ga-\nrantiscono un’astrazione tra la logica di business e l’accesso ai dati. Per assicurare uno stato coerente del database\ndurante l’esecuzione dei test, sono stati creati tre file SQL specifici:\n• reset.sql: elimina tutte le tabelle del database tramite comandi DROP TABLE, garantendo un ambiente\npulito prima di ogni test.\n• ProgettoSWE.sql: definisce lo schema del database, creando tutte le tabelle necessarie con i relativi\nvincoli e strutture.\n• InserimentoProgettoSWE.sql: popola le tabelle con dati iniziali, consentendo di inizializzare il\ndatabase con uno stato predefinito.\nPer\nmantenere\nla\ncoerenza\ndurante\ni\ntest,\ni\nfile\nvengono\neseguiti\nin\nsequenza\n(reset.sql,\nProgettoSWE.sql,\nInserimentoProgettoSWE.sql) all’interno delle funzioni beforeEach e\nafterEach, garantendo che ogni test operi su un database nello stesso stato iniziale e che le modifiche effettuate\ndurante i test vengano eliminate al termine.\n24\n",
  "26": "Samuele Lattanzi\nIngegneria del Software\n4\nTest\n4.1\nBusiness Logic Test\nIn questa sezione vengono presentati i test sui metodi esposti dalle classi del pacchetto Business Logic. Essi mirano\na verificare il comportamento della piattaforma rispetto ai requisiti funzionali, senza fare assunzioni sulla struttura\ninterna delle classi.\nL’obiettivo principale dei test `e stato quello di validare il flusso operativo standard, come l’aggiunta di un\nvideogioco al carrello, l’esecuzione di un acquisto, o l’installazione di un videogioco nella libreria di un utente.\nTuttavia, particolare attenzione `e stata posta sui casi di fallimento e sui comportamenti anomali, come tentativi di\nautenticazione con credenziali errate, installazione di videogiochi non acquistati, o disinstallazione di videogiochi\nnon installati. Questi scenari sono stati testati per garantire che il sistema gestisca correttamente le eccezioni e\nfornisca feedback appropriati, mantenendo la robustezza e l’affidabilit`a della piattaforma.\nI test sono stati implementati utilizzando il framework JUnit 5, con l’inizializzazione del database tramite script\nSQL (reset.sql, ProgettoSWE.sql, InserimentoProgettoSWE.sql),che ha permesso di caricare\ndati predefiniti per simulare scenari realistici senza creare nuovi oggetti, in linea con i requisiti della piattaforma.\n4.1.1\nUtenteControllerTest\nI test in UtenteControllerTest verificano il comportamento delle operazioni legate agli utenti, come la re-\ngistrazione, l’autenticazione, la ricarica del fondo e l’attivazione degli abbonamenti, rispetto ai requisiti funzionali.\nI test implementati in UtenteControllerTest coprono i seguenti scenari:\n• testRegistraUtente Successo: Verifica la registrazione di un nuovo utente con credenziali uniche. Si aspetta\nche il metodo registraUtente restituisca un oggetto Utente non nullo con lo stesso username fornito\n(es. \"nuovoUser\").\n• testRegistraUtente UsernameEsistente: Testa il tentativo di registrazione con un username gi`a esistente\n(es. \"mario\"). Si aspetta che venga lanciata un’IllegalArgumentException.\n• testAutenticaUtente CredenzialiValide: Valida l’autenticazione di un utente con credenziali corrette (es.\n\"mario\", \"password123\"). Si aspetta che venga restituito un oggetto Utente non nullo.\n• testRicaricaFondo Successo: Verifica la ricarica del fondo di un utente (es. \"mario\") con un importo\nvalido (es. 30.0). Si aspetta che il fondo aggiornato sia incrementato correttamente (es. fondo iniziale +\n30.0).\n• testAttivaAbbonamento Successo: Verifica l’attivazione di un abbonamento Silver per un utente con\nfondi sufficienti (es. \"luigi\"). Si aspetta che l’abbonamento sia attivo e che il fondo venga ridotto di\n9.99.\n• testAttivaAbbonamento Fallimento FondiInsufficienti: Testa l’attivazione di un abbonamento Silver\nper un utente con fondi insufficienti (es.\n\"toad\", fondo 0.0).\nSi aspetta che venga lancia-\nta un’IllegalStateException con il messaggio \"Fondo insufficiente per attivare\nl’abbonamento Silver\".\n@Test\nvoid testRegistraUtente_Successo() {\nUtente nuovo = new Utente(0, \"nuovoUser\", \"pass123\", \"nuovo@email.com\",\nfalse, 0.0);\nUtente res = utenteController.registraUtente(nuovo);\nassertNotNull(res);\nassertEquals(\"nuovoUser\", res.getUsername());\n}\n@Test\nvoid testRegistraUtente_UsernameEsistente() {\nUtente u = new Utente(0, \"mario\", \"pwd\", \"dup@email.com\", false, 0.0);\nassertThrows(IllegalArgumentException.class, () -> utenteController.\nregistraUtente(u));\n}\n25\n",
  "27": "Samuele Lattanzi\nIngegneria del Software\n@Test\nvoid testAutenticaUtente_CredenzialiValide() {\nUtente res = utenteController.autenticaUtente(\"mario\", \"password123\");\nassertNotNull(res);\n}\n@Test\nvoid testRicaricaFondo_Successo() {\nUtente u = utenteController.autenticaUtente(\"mario\", \"password123\");\ndouble fondoIniziale = u.getFondo();\nutenteController.ricaricaFondo(u, 30.0);\nUtente aggiornato = utenteController.autenticaUtente(\"mario\", \"password123\")\n;\nassertEquals(fondoIniziale + 30.0, aggiornato.getFondo(), 0.01);\n}\n@Test\nvoid testAttivaAbbonamento_Successo() {\nUtente utente = utenteController.autenticaUtente(\"luigi\", \"password456\");\ndouble fondoIniziale = utente.getFondo();\nLocalDate oggi = LocalDate.now();\nAbbonamento abbonamento = new Abbonamento(0, utente.getId(), oggi, oggi.\nplusMonths(1), \"attivo\", \"Silver\");\nutenteController.attivaAbbonamento(utente, abbonamento);\nUtente aggiornato = utenteController.autenticaUtente(\"luigi\", \"password456\")\n;\nassertTrue(aggiornato.isAbbonamentoAttivo());\nassertEquals(fondoIniziale - 9.99, aggiornato.getFondo(), 0.01);\n}\n@Test\nvoid testAttivaAbbonamento_Fallimento_FondiInsufficienti() {\nUtente utente = utenteController.autenticaUtente(\"toad\", \"password101\");\nLocalDate oggi = LocalDate.now();\nAbbonamento abbonamento = new Abbonamento(0, utente.getId(), oggi, oggi.\nplusMonths(1), \"attivo\", \"Silver\");\nException exception = assertThrows(IllegalStateException.class, () -> {\nutenteController.attivaAbbonamento(utente, abbonamento);\n});\nassertEquals(\"Fondo insufficiente per attivare l’abbonamento Silver\",\nexception.getMessage());\n}\n}\nSnippet 28: Test di UtenteController\n4.1.2\nCatalogoControllerTest\nI test in CatalogoControllerTest verificano il comportamento delle operazioni legate alla gestione del\ncatalogo di videogiochi, come l’aggiunta, la modifica, l’eliminazione, l’impostazione dello stato gratuito dei\nvideogiochi, da parte dell’admin, e la ricerca.\nI test implementati in CatalogoControllerTest coprono i seguenti scenari (quelli sulla modifica e\nl’eliminazione vengono coperti con lo stesso approccio di quelli sull’aggiunta):\n• testAggiungiVideogioco Successo: Verifica l’aggiunta di un nuovo videogioco al catalogo da parte di un\namministratore (es. admin). Si aspetta che il metodo aggiungiVideogioco inserisca correttamente il\nvideogioco (es. \"New Game\") e che sia ritrovabile tramite una ricerca per genere (es. \"RPG\").\n• testAggiungiVideogioco Fallimento VideogiocoEsistente:\nTesta il tentativo di aggiungere un vi-\ndeogioco\ngi`a\nesistente\n(es.\n\"Super Mario Odyssey\").\nSi\naspetta\nche\nvenga\nlanciata\nun’IllegalArgumentException con il messaggio \"Videogioco gi`a esistente\", garanten-\ndo che la piattaforma impedisca duplicazioni.\n26\n",
  "28": "Samuele Lattanzi\nIngegneria del Software\n• testCercaVideogiochi Successo: Verifica la ricerca di videogiochi per genere (es. \"Platform\"). Si\naspetta che il metodo cercaVideogiochi restituisca una lista non vuota contenente i videogiochi\ncorrispondenti (es. \"Super Mario Odyssey\").\n• testCercaVideogiochi Fallimento NessunRisultato: Testa la ricerca di videogiochi con un genere inesi-\nstente (es. \"NonEsistente\"). Si aspetta che il metodo cercaVideogiochi restituisca una lista\nvuota, indicando l’assenza di risultati.\n@Test\nvoid testAggiungiVideogioco_Successo() {\nAdmin admin = new Admin(1, \"admin\", \"admin123\");\nVideogioco videogioco = new Videogioco(0, \"New Game\", \"RPG\", \"PC\", 29.99,\nLocalDate.now(), false);\ncatalogoController.aggiungiVideogioco(videogioco, admin);\nList<Videogioco> videogiochi = catalogoController.cercaVideogiochi(\"RPG\", null,\nnull);\nassertFalse(videogiochi.isEmpty());\nassertTrue(videogiochi.stream().anyMatch(v -> v.getTitolo().equals(\"New Game\")))\n;\n}\n@Test\nvoid testAggiungiVideogioco_Fallimento_VideogiocoEsistente() {\nAdmin admin = new Admin(1, \"admin\", \"admin123\");\nVideogioco videogioco = new Videogioco(1, \"Super Mario Odyssey\", \"Platform\", \"\nNintendo Switch\", 59.99, LocalDate.parse(\"2017-10-27\"), false);\nException exception = assertThrows(IllegalArgumentException.class, () -> {\ncatalogoController.aggiungiVideogioco(videogioco, admin);\n});\nassertEquals(\"Videogioco gia’ esistente\", exception.getMessage());\n}\n@Test\nvoid testCercaVideogiochi_Successo() {\nList<Videogioco> result = catalogoController.cercaVideogiochi(\"Platform\", null,\nnull);\nassertFalse(result.isEmpty());\nassertEquals(\"Super Mario Odyssey\", result.get(0).getTitolo());\n}\n@Test\nvoid testCercaVideogiochi_Fallimento_NessunRisultato() {\nList<Videogioco> result = catalogoController.cercaVideogiochi(\"NonEsistente\",\nnull, null);\nassertTrue(result.isEmpty());\n}\nSnippet 29: Test di CatalogoController\n4.1.3\nCarrelloControllerTest\nI test in CarrelloControllerTest verificano il comportamento delle operazioni legate alla gestione del\ncarrello degli utenti, come l’aggiunta e la rimozione di videogiochi, l’esecuzione degli acquisti e la gestione degli\nobserver per le notifiche, rispetto ai requisiti funzionali della piattaforma.\nI test implementati in CarrelloControllerTest coprono i seguenti scenari:\n• testAggiungiAlCarrello Successo:\nVerifica l’aggiunta di un videogioco (es.\n\"Super Mario\nOdyssey\") al carrello di un utente autenticato (es.\n\"mario\").\nSi aspetta che il metodo\naggiungiAlCarrello completi l’operazione senza errori e che il videogioco sia presente nel carrello.\n• testRimuoviDalCarrello Successo:\nVerifica la rimozione di un videogioco (es.\n\"Super Mario\nOdyssey\") dal carrello di un utente (es. \"mario\"). Si aspetta che il metodo rimuoviDalCarrello\ncompleti l’operazione senza errori e che il videogioco non sia pi`u presente nel carrello.\n27\n",
  "29": "Samuele Lattanzi\nIngegneria del Software\n• testEseguiAcquisto Successo: Verifica l’esecuzione di un acquisto per un carrello di un utente con fondi\nsufficienti (es. \"luigi\" con fondo di 220.0). Si aspetta che il metodo eseguiAcquisto restituisca\ntrue e che il fondo dell’utente venga ridotto correttamente (es. 220.00 - 69.99).\n• testEseguiAcquisto Fallimento FondoInsufficiente:\nTesta il tentativo di eseguire un acquisto con\nfondi insufficienti (es.\n\"mario\" con videogioco da 59.99).\nSi aspetta che venga lanciata\nun’IllegalArgumentException, garantendo che la piattaforma impedisca acquisti non validi.\n• testEseguiAcquisto Fallimento VideogiocoGiaInLibreria: Testa il tentativo di acquistare un videogioco\ngi`a presente nella libreria dell’utente (es. \"luigi\" tenta di riacquistare \"Super Mario Odyssey\"). Si\naspetta che venga lanciata un’IllegalArgumentException, garantendo che la piattaforma prevenga\nacquisti duplicati.\n• testAggiungiRimuoviObserver Successo:\nVerifica\nl’aggiunta\ne\nla\nrimozione\ndi\nun\nobserver\n(es.\nLibreriaController) al carrello.\nSi aspetta che i metodi aggiungiObserver e\nrimuoviObserver completino le operazioni senza errori.\n• testNotificaAcquistoCompletato Successo: Verifica la notifica di un acquisto completato a un observer per\nun carrello di un utente (es. \"mario\"). Si aspetta che il metodo notificaAcquistoCompletato\ncompleti l’operazione senza errori.\n@Test\nvoid testAggiungiAlCarrello_Successo() {\nUtente utente = utenteController.autenticaUtente(\"mario\", \"password123\");\nVideogioco videogioco = new Videogioco(1, \"Super Mario Odyssey\", \"Platform\", \"\nNintendo Switch\", 59.99, LocalDate.parse(\"2017-10-27\"), false);\nassertDoesNotThrow(() -> carrelloController.aggiungiAlCarrello(utente,\nvideogioco));\nCarrello carrello = carrelloController.getCarrello(utente);\nassertTrue(carrello.getVideogiochi().stream().anyMatch(v -> v.getId() == 1));\n}\n@Test\nvoid testRimuoviDalCarrello_Successo() {\nUtente utente = utenteController.autenticaUtente(\"mario\", \"password123\");\nVideogioco videogioco = new Videogioco(1, \"Super Mario Odyssey\", \"Platform\", \"\nNintendo Switch\", 59.99, LocalDate.parse(\"2017-10-27\"), false);\ncarrelloController.aggiungiAlCarrello(utente, videogioco);\nassertDoesNotThrow(() -> carrelloController.rimuoviDalCarrello(utente,\nvideogioco));\nCarrello carrello = carrelloController.getCarrello(utente);\nassertFalse(carrello.getVideogiochi().stream().anyMatch(v -> v.getId() == 1));\n}\n@Test\nvoid testEseguiAcquisto_Successo() {\nUtente utente = utenteController.autenticaUtente(\"luigi\", \"password456\");\nutenteController.ricaricaFondo(utente, 200.0);\nCarrello carrello = carrelloController.getCarrello(utente);\nboolean result = carrelloController.eseguiAcquisto(carrello);\nassertTrue(result);\nUtente aggiornato = utenteController.autenticaUtente(\"luigi\", \"password456\");\nassertEquals(220.00 - 69.99, aggiornato.getFondo(), 0.01);\n}\n@Test\nvoid testEseguiAcquisto_Fallimento_FondoInsufficiente() {\nUtente utente = utenteController.autenticaUtente(\"mario\", \"password123\");\nVideogioco videogioco = new Videogioco(1, \"Super Mario Odyssey\", \"Platform\", \"\nNintendo Switch\", 59.99, LocalDate.parse(\"2017-10-27\"), false);\ncarrelloController.aggiungiAlCarrello(utente, videogioco);\nCarrello carrello = carrelloController.getCarrello(utente);\n28\n",
  "30": "Samuele Lattanzi\nIngegneria del Software\nassertThrows(IllegalArgumentException.class, () -> carrelloController.\neseguiAcquisto(carrello));\n}\n@Test\nvoid testEseguiAcquisto_Fallimento_VideogiocoGiaInLibreria() {\nUtente utente = utenteController.autenticaUtente(\"luigi\", \"password456\");\nutenteController.ricaricaFondo(utente, 200.0);\nVideogioco videogioco = new Videogioco(1, \"Super Mario Odyssey\", \"Platform\", \"\nNintendo Switch\", 59.99, LocalDate.parse(\"2017-10-27\"), false);\ncarrelloController.aggiungiAlCarrello(utente, videogioco);\nCarrello carrello = carrelloController.getCarrello(utente);\ncarrelloController.eseguiAcquisto(carrello);\ncarrelloController.aggiungiAlCarrello(utente, videogioco);\nassertThrows(IllegalArgumentException.class, () -> carrelloController.\neseguiAcquisto(carrello));\n}\n@Test\nvoid testAggiungiRimuoviObserver_Successo() {\nObserver observer = new LibreriaController(new Libreria(0, 1), new\nStatisticheController());\nassertDoesNotThrow(() -> carrelloController.aggiungiObserver(observer));\nassertDoesNotThrow(() -> carrelloController.rimuoviObserver(observer));\n}\n@Test\nvoid testNotificaAcquistoCompletato_Successo() {\nUtente utente = utenteController.autenticaUtente(\"mario\", \"password123\");\nCarrello carrello = new Carrello(0, utente.getId());\nObserver observer = new LibreriaController(new Libreria(0, utente.getId()), new\nStatisticheController());\ncarrelloController.aggiungiObserver(observer);\nassertDoesNotThrow(() -> carrelloController.notificaAcquistoCompletato(utente,\ncarrello));\n}\nSnippet 30: Test di CarrelloController\n4.1.4\nLibreriaControllerTest\nI test in LibreriaControllerTest verificano il comportamento delle operazioni legate alla gestione della\nlibreria di videogiochi di un utente, come il caricamento della libreria, l’installazione e la disinstallazione dei\nvideogiochi, e la gestione degli acquisti.\nI test implementati in LibreriaControllerTest coprono i seguenti scenari:\n• testCaricaLibreria Successo: Verifica il caricamento della libreria di un utente autenticato (es. \"toad\").\nSi aspetta che il metodo caricaLibreria completi l’operazione senza errori e che l’ID dell’utente\ncorrisponda a quello della libreria caricata.\n• testInstallaVideogioco Successo:\nVerifica l’installazione di un videogioco acquistato (es.\n\"Super\nMario Odyssey\") nella libreria di un utente (es.\n\"luigi\").\nSi aspetta che il metodo\ninstallaVideogioco completi l’operazione senza errori e che il videogioco risulti installato.\n• testInstallaVideogioco Fallimento VideogiocoGiaInstallato: Testa il tentativo di installare un videogioco\ngi`a installato (es. \"Super Mario Odyssey\") nella libreria di un utente (es. \"mario\"). Si aspetta che\nvenga lanciata un’IllegalStateException, garantendo che la piattaforma gestisca correttamente lo\nstato dei videogiochi.\n• testDisinstallaVideogioco Successo: Verifica la disinstallazione di un videogioco installato (es. \"Super\nMario Odyssey\") dalla libreria di un utente (es.\n\"mario\").\nSi aspetta che il metodo\ndisinstallaVideogioco completi l’operazione senza errori e che il videogioco non risulti pi`u\ninstallato.\n29\n",
  "31": "Samuele Lattanzi\nIngegneria del Software\n• testDisinstallaVideogioco Fallimento VideogiocoNonInstallato: Testa il tentativo di disinstallare un vi-\ndeogioco non installato (es. \"Fortnite\") dalla libreria di un utente (es. \"mario\"). Si aspetta che venga\nlanciata un’IllegalStateException, garantendo la gestione degli errori.\n• testOnAcquistoCompletato Successo: Verifica l’aggiornamento della libreria di un utente (es. \"toad\")\nin seguito a un acquisto completato (es.\n\"Super Mario Odyssey\").\nSi aspetta che il metodo\neseguiAcquisto del CarrelloController notifichi correttamente la libreria e che il videogioco\nrisulti acquistato.\n@Test\nvoid testCaricaLibreria_Successo() {\nUtente toad = utenteController.autenticaUtente(\"toad\", \"password101\");\nassertDoesNotThrow(() -> libreriaController.caricaLibreria(toad));\nassertEquals(toad.getId(), libreriaController.getLibreria().getIdUtente());\n}\n@Test\nvoid testInstallaVideogioco_Successo() {\nUtente luigi = utenteController.autenticaUtente(\"luigi\", \"password456\");\nutenteController.ricaricaFondo(luigi, 200.0);\nVide modossey = catalogoController.getVideogiochiPerUtente(null)\n.stream()\n.filter(v -> v.getId() == 1)\n.findFirst()\n.orElseThrow(() -> new IllegalStateException(\"Videogioco con ID 1 non\ntrovato\"));\ncarrelloController.aggiungiAlCarrello(luigi, superMarioOdyssey);\nCarrello carrello = carrelloController.getCarrello(luigi);\ncarrelloController.eseguiAcquisto(carrello);\nlibreriaController.caricaLibreria(luigi);\nassertDoesNotThrow(() -> libreriaController.installaVideogioco(luigi,\nsuperMarioOdyssey));\nassertTrue(libreriaController.getLibreria().isVideogiocoInstallato(\nsuperMarioOdyssey));\n}\n@Test\nvoid testInstallaVideogioco_Fallimento_VideogiocoGiaInstallato() {\nUtente mario = utenteController.autenticaUtente(\"mario\", \"password123\");\nVideogioco superMarioOdyssey = catalogoController.getVideogiochiPerUtente(null)\n.stream()\n.filter(v -> v.getId() == 1)\n.findFirst()\n.orElseThrow(() -> new IllegalStateException(\"Videogioco con ID 1 non\ntrovato\"));\nlibreriaController.caricaLibreria(mario);\nassertThrows(IllegalStateException.class, () -> libreriaController.\ninstallaVideogioco(mario, superMarioOdyssey));\n}\n@Test\nvoid testDisinstallaVideogioco_Successo() {\nUtente mario = utenteController.autenticaUtente(\"mario\", \"password123\");\nVideogioco superMarioOdyssey = catalogoController.getVideogiochiPerUtente(null)\n.stream()\n.filter(v -> v.getId() == 1)\n.findFirst()\n.orElseThrow(() -> new IllegalStateException(\"Videogioco con ID 1 non\ntrovato\"));\nlibreriaController.caricaLibreria(mario);\nassertDoesNotThrow(() -> libreriaController.disinstallaVideogioco(mario,\nsuperMarioOdyssey));\n30\n",
  "32": "Samuele Lattanzi\nIngegneria del Software\nassertFalse(libreriaController.getLibreria().isVideogiocoInstallato(\nsuperMarioOdyssey));\n}\n@Test\nvoid testDisinstallaVideogioco_Fallimento_VideogiocoNonInstallato() {\nUtente mario = utenteController.autenticaUtente(\"mario\", \"password123\");\nVideogioco fortnite = catalogoController.getVideogiochiPerUtente(null)\n.stream()\n.filter(v -> v.getId() == 3)\n.findFirst()\n.orElseThrow(() -> new IllegalStateException(\"Videogioco con ID 3 non\ntrovato\"));\nlibreriaController.caricaLibreria(mario);\nassertThrows(IllegalStateException.class, () -> libreriaController.\ndisinstallaVideogioco(mario, fortnite));\n}\n@Test\nvoid testOnAcquistoCompletato_Successo() {\nUtente toad = utenteController.autenticaUtente(\"toad\", \"password101\");\nVideogioco superMarioOdyssey = catalogoController.getVideogiochiPerUtente(null)\n.stream()\n.filter(v -> v.getId() == 1)\n.findFirst()\n.orElseThrow(() -> new IllegalStateException(\"Videogioco con ID 1 non\ntrovato\"));\nutenteController.ricaricaFondo(toad, 100.0);\nlibreriaController.caricaLibreria(toad);\ncarrelloController.aggiungiAlCarrello(toad, superMarioOdyssey);\nCarrello carrello = carrelloController.getCarrello(toad);\ncarrelloController.aggiungiObserver(libreriaController);\nassertDoesNotThrow(() -> carrelloController.eseguiAcquisto(carrello));\nassertTrue(libreriaController.getLibreria().getVideogiochiAcquistati().stream().\nanyMatch(v -> v.getId() == 1));\n}\nSnippet 31: Test di LibreriaController\n4.1.5\nStatisticheControllerTest\nI test in StatisticheControllerTest verificano il comportamento delle operazioni legate alla gestione\ndelle statistiche di gioco degli utenti, come l’aggiornamento del tempo di gioco e il recupero di statistiche e\nachievement.\nI test implementati in StatisticheControllerTest coprono i seguenti scenari:\n• testGetStatistiche Successo: Verifica il recupero delle statistiche di un videogioco per un utente (es.\n\"mario\", \"Super Mario Odyssey\"). Si aspetta che il metodo getStatistiche restituisca un\noggetto StatisticheVideogioco non nullo con il tempo di gioco atteso (es. 7200 secondi).\n• testGetStatistiche Fallimento NessunaStatistica: Testa il recupero delle statistiche per un videogioco\nnon associato a un utente (es.\n\"luigi\", \"Super Mario Odyssey\").\nSi aspetta che il metodo\ngetStatistiche restituisca null, indicando l’assenza di statistiche.\n• testGetUtenteAchievements Successo:\nVerifica\nil\nrecupero\ndegli\nachievement\ndi\nun\nvideogio-\nco per un utente (es.\n\"mario\",\n\"Super Mario Odyssey\").\nSi aspetta che il metodo\ngetUtenteAchievements restituisca una lista non vuota contenente achievement come \"Primo\nBoss\".\n• testGetUtenteAchievements Fallimento NessunAchievement: Testa il recupero degli achievement per un\nvideogioco non associato a un utente (es. \"luigi\", \"Super Mario Odyssey\"). Si aspetta che il\nmetodo getUtenteAchievements restituisca una lista vuota.\n31\n",
  "33": "Samuele Lattanzi\nIngegneria del Software\n@Test\nvoid testGetStatistiche_Successo() {\nUtente utente = new Utente(1, \"mario\", \"password123\", \"mario@email.com\", true,\n50.0);\nVideogioco videogioco = new Videogioco(1, \"Super Mario Odyssey\", \"Platform\", \"\nNintendo Switch\", 59.99, LocalDate.parse(\"2017-10-27\"), false);\nStatisticheVideogioco statistiche = statisticheController.getStatistiche(utente,\nvideogioco);\nassertNotNull(statistiche);\nassertEquals(7200, statistiche.getTempoGioco());\n}\n@Test\nvoid testGetStatistiche_Fallimento_NessunaStatistica() {\nUtente utente = new Utente(2, \"luigi\", \"password456\", \"luigi@email.com\", false,\n20.0);\nVideogioco videogioco = new Videogioco(1, \"Super Mario Odyssey\", \"Platform\", \"\nNintendo Switch\", 59.99, LocalDate.parse(\"2017-10-27\"), false);\nStatisticheVideogioco statistiche = statisticheController.getStatistiche(utente,\nvideogioco);\nassertNull(statistiche);\n}\n@Test\nvoid testGetUtenteAchievements_Successo() {\nUtente utente = new Utente(1, \"mario\", \"password123\", \"mario@email.com\", true,\n50.0);\nVideogioco videogioco = new Videogioco(1, \"Super Mario Odyssey\", \"Platform\", \"\nNintendo Switch\", 59.99, LocalDate.parse(\"2017-10-27\"), false);\nList<Achievement> achievements = statisticheController.getUtenteAchievements(\nutente, videogioco);\nassertFalse(achievements.isEmpty());\nassertTrue(achievements.stream().anyMatch(a -> a.getNome().equals(\"Primo Boss\"))\n);\n}\n@Test\nvoid testGetUtenteAchievements_Fallimento_NessunAchievement() {\nUtente utente = new Utente(2, \"luigi\", \"password456\", \"luigi@email.com\", false,\n20.0);\nVideogioco videogioco = new Videogioco(1, \"Super Mario Odyssey\", \"Platform\", \"\nNintendo Switch\", 59.99, LocalDate.parse(\"2017-10-27\"), false);\nList<Achievement> achievements = statisticheController.getUtenteAchievements(\nutente, videogioco);\nassertTrue(achievements.isEmpty());\n}\nSnippet 32: Test di StatisticheController\n4.1.6\nAchievementControllerTest\nI test in AchievementControllerTest verificano il comportamento delle operazioni legate alla gestione\ndegli achievement dei videogiochi, come l’aggiunta, la modifica, l’eliminazione e il recupero degli achievement.\nI test implementati in AchievementControllerTest coprono i seguenti scenari:\n• testAggiungiAchievement Successo: Verifica l’aggiunta di un nuovo achievement (es. \"Completato\nLivello 1\") per un videogioco (es. ID 1) da parte di un amministratore autenticato (es. \"admin\"). Si\naspetta che il metodo aggiungiAchievement completi l’operazione senza errori e che l’achievement\nsia recuperabile.\n• testAggiungiAchievement Fallimento AdminNonAutenticato: Testa il tentativo di aggiungere un achie-\nvement da parte di un amministratore non autenticato (es. \"fakeAdmin\"). Si aspetta che venga lanciata\nun’SecurityException, garantendo che la piattaforma impedisca modifiche non autorizzate.\n32\n",
  "34": "Samuele Lattanzi\nIngegneria del Software\n• testModificaAchievement Successo: Verifica la modifica di un achievement esistente (es. \"Completato\nLivello 1\") con nuovi dati (es.\n\"Completato Livello 1 Aggiornato\", tempo richiesto\n1200). Si aspetta che il metodo modificaAchievement aggiorni correttamente l’achievement.\n• testGetAchievementsByVideogioco Fallimento NessunAchievement: Testa il recupero degli achieve-\nment per un videogioco senza achievement associati (es.\nID 999).\nSi aspetta che il metodo\ngetAchievementsByVideogioco restituisca una lista vuota.\n@Test\nvoid testAggiungiAchievement_Successo() {\nAdmin admin = adminController.autenticaAdmin(\"admin\", \"admin123\");\nassertDoesNotThrow(() -> achievementController.aggiungiAchievement(1, \"\nCompletato Livello 1\", \"Completa il primo livello\", 600, admin));\nList<Achievement> achievements = achievementController.\ngetAchievementsByVideogioco(1);\nassertFalse(achievements.isEmpty());\nassertTrue(achievements.stream().anyMatch(a -> a.getNome().equals(\"Completato\nLivello 1\")));\n}\n@Test\nvoid testAggiungiAchievement_Fallimento_AdminNonAutenticato() {\nAdmin admin = new Admin(999, \"fakeAdmin\", \"fakePass\");\nassertThrows(SecurityException.class, () -> achievementController.\naggiungiAchievement(1, \"Completato Livello 1\", \"Completa il primo livello\",\n600, admin));\n}\n@Test\nvoid testGetAchievementsByVideogioco_Successo() {\nAdmin admin = adminController.autenticaAdmin(\"admin\", \"admin123\");\nachievementController.aggiungiAchievement(1, \"Completato Livello 1\", \"Completa\nil primo livello\", 600, admin);\nList<Achievement> achievements = achievementController.\ngetAchievementsByVideogioco(1);\nassertFalse(achievements.isEmpty());\nassertTrue(achievements.stream().anyMatch(a -> a.getNome().equals(\"Completato\nLivello 1\")));\n}\n@Test\nvoid testGetAchievementsByVideogioco_Fallimento_NessunAchievement() {\nList<Achievement> achievements = achievementController.\ngetAchievementsByVideogioco(999);\nassertTrue(achievements.isEmpty());\n}\nSnippet 33: Test di AchievementController\n4.1.7\nAdminControllerTest\nI test in AdminControllerTest verificano il comportamento delle operazioni legate alla gestione degli am-\nministratori, come la registrazione e l’autenticazione.\nI test implementati in AdminControllerTest coprono i seguenti scenari:\n• testRegistraAdmin Fallimento UsernameEsistente: Testa il tentativo di registrare un amministratore con\nun username gi`a esistente (es. \"admin\"). Si aspetta che il metodo registraAdmin restituisca false,\ngarantendo che la piattaforma impedisca registrazioni duplicate.\n• testAutenticaAdmin Successo: Verifica l’autenticazione di un amministratore con credenziali corrette (es.\n\"admin\", \"admin123\"). Si aspetta che il metodo autenticaAdmin restituisca un oggetto Admin\nnon nullo con l’username corretto.\n33\n",
  "35": "Samuele Lattanzi\nIngegneria del Software\n• testAutenticaAdmin Fallimento UsernameNonEsistente:\nTesta il tentativo di autenticazione di un\namministratore con un username inesistente (es.\n\"nonEsistente\").\nSi aspetta che il metodo\nautenticaAdmin restituisca null, garantendo la gestione degli errori di autenticazione.\n@Test\nvoid testRegistraAdmin_Fallimento_UsernameEsistente() {\nAdmin admin = new Admin(0, \"admin\", \"nuovaPass\");\nboolean result = adminController.registraAdmin(admin);\nassertFalse(result);\n}\n@Test\nvoid testAutenticaAdmin_Successo() {\nAdmin admin = adminController.autenticaAdmin(\"admin\", \"admin123\");\nassertNotNull(admin);\nassertEquals(\"admin\", admin.getUsername());\n}\n@Test\nvoid testAutenticaAdmin_Fallimento_UsernameNonEsistente() {\nAdmin admin = adminController.autenticaAdmin(\"nonEsistente\", \"pass\");\nassertNull(admin);\n}\nSnippet 34: Test di AdminController\n4.2\nDomain Model Test\nIl modello di dominio della piattaforma `e costituito da classi semplici che rappresentano le entit`a principali del si-\nstema, come Utente, Videogioco, Carrello, Abbonamento, Libreria, StatisticheVideogioco\ne Achievement. Queste classi sono progettate principalmente come strutture dati, implementando metodi getter\ne setter per accedere e modificare gli attributi. Data la loro semplicit`a e il ruolo di contenitori di dati, si `e scelto di\nlimitare i test unitari a una singola classe del modello di dominio, la classe Carrello, che riveste un ruolo cen-\ntrale nella gestione del calcolo del totale dei videogiochi acquistati. In particolare, i test su Carrello verificano\nil corretto funzionamento del pattern Strategy utilizzato per determinare i prezzi in base al tipo di abbonamento\ndell’utente (es. NonAbbonato, Silver, Gold), garantendo che il calcolo del totale rifletta correttamente gli\nsconti applicabili e la gestione di videogiochi gratuiti o a pagamento.\n4.2.1\nCarrelloTest\nI test in CarrelloTest verificano il comportamento della classe Carrello, con particolare attenzione alle\noperazioni di aggiunta e rimozione di videogiochi e al calcolo del totale del carrello in base al pattern Strategy.\nI test implementati in CarrelloTest coprono i seguenti scenari:\n• testAddVideogioco Successo NuovoVideogioco: Verifica l’aggiunta di un nuovo videogioco (es. \"Super\nMario Odyssey\") al carrello. Si aspetta che il metodo addVideogioco aggiunga correttamente il\nvideogioco e che la lista dei videogiochi contenga un solo elemento.\n• testAddVideogioco Fallimento VideogiocoDuplicato: Testa il tentativo di aggiungere un videogioco gi`a\npresente nel carrello (es. \"Super Mario Odyssey\"). Si aspetta che il metodo addVideogioco non\naggiunga duplicati, mantenendo la lista dei videogiochi con un solo elemento.\n• testRemoveVideogioco Successo:\nVerifica la rimozione di un videogioco presente nel carrello (es.\n\"Super Mario Odyssey\"). Si aspetta che il metodo removeVideogioco rimuova correttamente\nil videogioco, lasciando il carrello vuoto.\n• testSetPrezzoStrategy Successo:\nVerifica\nl’impostazione\ndella\nstrategia\ndi\nprezzo\nGoldAbbonatoPrezzoStrategy e il calcolo del totale per un videogioco a pagamento (es.\n\"Super Mario Odyssey\"). Si aspetta che il metodo getTotale restituisca il prezzo scontato del\n20% (es. 59.99 * 0.8).\n34\n",
  "36": "Samuele Lattanzi\nIngegneria del Software\n• testGetTotale NonAbbonato GiocoAPagamento:\nVerifica\nil\ncalcolo\ndel\ntotale\nper\nun\ncarrel-\nlo\ncontenente\nun\nvideogioco\na\npagamento\n(es.\n\"Super Mario Odyssey\")\ncon\nstrategia\nNonAbbonatoPrezzoStrategy. Si aspetta che il metodo getTotale restituisca il prezzo pieno (es.\n59.99).\n• testGetTotale GoldAbbonato GiocoAPagamento:\nVerifica\nil\ncalcolo\ndel\ntotale\nper\nun\ncarrel-\nlo\ncontenente\nun\nvideogioco\na\npagamento\n(es.\n\"Super Mario Odyssey\")\ncon\nstrategia\nGoldAbbonatoPrezzoStrategy. Si aspetta che il metodo getTotale restituisca il prezzo scontato\ndel 20% (es. 59.99 * 0.8).\n• testGetTotale GoldAbbonato GiocoGratuito: Verifica il calcolo del totale per un carrello contenente un\nvideogioco gratuito (es. \"Fortnite\"). Si aspetta che il metodo getTotale restituisca 0.0.\n@Test\nvoid testAddVideogioco_Successo_NuovoVideogioco() {\ncarrello.addVideogioco(marioOdyssey);\nList<Videogioco> videogiochi = carrello.getVideogiochi();\nassertEquals(1, videogiochi.size());\nassertTrue(videogiochi.contains(marioOdyssey));\n}\n@Test\nvoid testAddVideogioco_Fallimento_VideogiocoDuplicato() {\ncarrello.addVideogioco(marioOdyssey);\ncarrello.addVideogioco(marioOdyssey);\nList<Videogioco> videogiochi = carrello.getVideogiochi();\nassertEquals(1, videogiochi.size());\nassertTrue(videogiochi.contains(marioOdyssey));\n}\n@Test\nvoid testRemoveVideogioco_Successo() {\ncarrello.addVideogioco(marioOdyssey);\ncarrello.removeVideogioco(marioOdyssey);\nList<Videogioco> videogiochi = carrello.getVideogiochi();\nassertTrue(videogiochi.isEmpty());\n}\n@Test\nvoid testSetPrezzoStrategy_Successo() {\nPrezzoStrategy goldStrategy = new GoldAbbonatoPrezzoStrategy();\ncarrello.setPrezzoStrategy(goldStrategy);\ncarrello.addVideogioco(marioOdyssey);\ndouble totale = carrello.getTotale(utente);\nassertEquals(59.99 * (1 - 0.2), totale, 0.01);\n}\n@Test\nvoid testGetTotale_NonAbbonato_GiocoAPagamento() {\ncarrello.setPrezzoStrategy(new NonAbbonatoPrezzoStrategy());\ncarrello.addVideogioco(marioOdyssey);\ndouble totale = carrello.getTotale(utente);\nassertEquals(59.99, totale, 0.01);\n}\n@Test\nvoid testGetTotale_GoldAbbonato_GiocoAPagamento() {\ncarrello.setPrezzoStrategy(new GoldAbbonatoPrezzoStrategy());\ncarrello.addVideogioco(marioOdyssey);\ndouble totale = carrello.getTotale(utente);\nassertEquals(59.99 * (1 - 0.2), totale, 0.01);\n}\n35\n",
  "37": "Samuele Lattanzi\nIngegneria del Software\n@Test\nvoid testGetTotale_GoldAbbonato_GiocoGratuito() {\ncarrello.setPrezzoStrategy(new GoldAbbonatoPrezzoStrategy());\ncarrello.addVideogioco(fortnite);\ndouble totale = carrello.getTotale(utente);\nassertEquals(0.0, totale, 0.01);\n}\nSnippet 35: Test di Carrello\n4.3\nTest del Pacchetto ORM\nI test delle classi DAO verificano il corretto funzionamento delle operazioni di creazione, lettura, aggiornamento ed\neliminazione (CRUD) per le entit`a del Domain Model, garantendo che i dati siano correttamente salvati, recuperati,\naggiornati ed eliminati nel database. Per assicurare la coerenza dei dati durante i test, ogni metodo di test `e precedu-\nto e seguito dall’esecuzione dei file SQL reset.sql, ProgettoSWE.sql e InserimentoProgettoSWE.sql,\ncome descritto nella sezione dedicata al database. I test si concentrano principalmente sui metodi che interagiscono\ndirettamente con il database, come save, update, findById, findByCriteria e delete, poich´e questi\nrappresentano i punti critici per la persistenza e il recupero dei dati. Particolare attenzione `e stata posta ai casi di\nfallimento (es. recupero di entit`a inesistenti o violazioni di vincoli) per verificare la robustezza della piattaforma\nnel gestire errori di interazione con il database.\n4.3.1\nVideogiocoDAOTest\nI test in VideogiocoDAOTest verificano il comportamento delle operazioni CRUD per l’entit`a Videogioco,\ncome il salvataggio, l’aggiornamento, il recupero e l’eliminazione di videogiochi nel database.\nI test implementati in VideogiocoDAOTest coprono i seguenti scenari:\n• testSave Successo: Verifica il salvataggio di un nuovo videogioco (es. \"Animal Crossing\") nel da-\ntabase. Si aspetta che il metodo save restituisca un oggetto Videogioco non nullo con un ID valido e\nattributi corretti (es. prezzo 59.99).\n• testUpdate Successo: Verifica l’aggiornamento di un videogioco esistente (es. ID 1, \"Super Mario\nOdyssey\") con un nuovo prezzo (es. 49.99). Si aspetta che il metodo update completi l’operazione\nsenza errori e che il videogioco aggiornato rifletta il nuovo prezzo.\n• testFindById Successo:\nVerifica il recupero di un videogioco per ID (es.\nID 1, \"Super Mario\nOdyssey\"). Si aspetta che il metodo findById restituisca un oggetto Videogioco non nullo con\ngli attributi attesi.\n• testFindById Fallimento IdNonEsistente: Testa il recupero di un videogioco con un ID inesistente (es.\nID 999). Si aspetta che il metodo findById restituisca null, garantendo la gestione degli errori.\n• testFindByCriteria Successo TuttiCriteri: Verifica la ricerca di videogiochi utilizzando tutti i criteri (es.\ngenere \"Platform\", piattaforma \"Nintendo Switch\", data 2017-10-27). Si aspetta che il meto-\ndo findByCriteria restituisca una lista non vuota contenente videogiochi come \"Super Mario\nOdyssey\".\n• testFindByCriteria Fallimento NessunRisultato: Testa la ricerca di videogiochi con un genere inesisten-\nte (es. \"NonEsistente\"). Si aspetta che il metodo findByCriteria restituisca una lista vuota,\nindicando l’assenza di risultati.\n• testDelete Successo: Verifica l’eliminazione di un videogioco dal database (es. \"Test Game\"). Si aspetta\nche il metodo delete completi l’operazione senza errori e che il videogioco non sia pi`u recuperabile tramite\nfindById.\n@Test\nvoid testSave_Successo() {\nVideogioco videogioco = new Videogioco(0, \"Animal Crossing\", \"Simulazione\", \"\nNintendo Switch\", 59.99, LocalDate.parse(\"2020-03-20\"), false);\nVideogioco saved = videogiocoDAO.save(videogioco);\n36\n",
  "38": "Samuele Lattanzi\nIngegneria del Software\nassertNotNull(saved);\nassertTrue(saved.getId() > 0);\nassertEquals(\"Animal Crossing\", saved.getTitolo());\nassertEquals(59.99, saved.getPrezzo(), 0.01);\n}\n@Test\nvoid testUpdate_Successo() {\nVideogioco videogioco = videogiocoDAO.findById(1);\nvideogioco.setPrezzo(49.99);\nassertDoesNotThrow(() -> videogiocoDAO.update(videogioco));\nVideogioco updated = videogiocoDAO.findById(1);\nassertEquals(49.99, updated.getPrezzo(), 0.01);\n}\n@Test\nvoid testFindById_Successo() {\nVideogioco videogioco = videogiocoDAO.findById(1);\nassertNotNull(videogioco);\nassertEquals(\"Super Mario Odyssey\", videogioco.getTitolo());\nassertEquals(59.99, videogioco.getPrezzo(), 0.01);\n}\n@Test\nvoid testFindById_Fallimento_IdNonEsistente() {\nVideogioco videogioco = videogiocoDAO.findById(999);\nassertNull(videogioco);\n}\n@Test\nvoid testFindByCriteria_Successo_TuttiCriteri() {\nList<Videogioco> videogiochi = videogiocoDAO.findByCriteria(\"Platform\", \"\nNintendo Switch\", LocalDate.parse(\"2017-10-27\"));\nassertFalse(videogiochi.isEmpty());\nassertTrue(videogiochi.stream().anyMatch(v -> v.getTitolo().equals(\"Super Mario\nOdyssey\")));\n}\n@Test\nvoid testFindByCriteria_Fallimento_NessunRisultato() {\nList<Videogioco> videogiochi = videogiocoDAO.findByCriteria(\"NonEsistente\", null\n, null);\nassertTrue(videogiochi.isEmpty());\n}\n@Test\nvoid testDelete_Successo() {\nVideogioco videogioco = videogiocoDAO.save(new Videogioco(0, \"Test Game\", \"Test\"\n, \"Test\", 10.0, LocalDate.now(), false));\nassertDoesNotThrow(() -> videogiocoDAO.delete(videogioco.getId()));\nVideogioco deleted = videogiocoDAO.findById(videogioco.getId());\nassertNull(deleted);\n}\nSnippet 36: Test di VideogiocoDAO\n4.3.2\nCarrelloDAOTest\nI test in CarrelloDAOTest verificano il comportamento delle operazioni CRUD per l’entit`a Carrello, come\nil salvataggio, l’aggiornamento, il recupero e l’eliminazione di carrelli nel database.\nI test implementati in CarrelloDAOTest coprono i seguenti scenari:\n37\n",
  "39": "Samuele Lattanzi\nIngegneria del Software\n• testSave Successo CarrelloEsistente: Verifica il salvataggio di un carrello esistente (es.\nID 1, utente\n\"mario\") con un nuovo videogioco (es.\n\"Minecraft\").\nSi aspetta che il metodo save aggiorni\ncorrettamente il carrello, includendo il nuovo videogioco e rimuovendo quelli non pi`u presenti.\n• testUpdate Successo: Verifica l’aggiornamento di un carrello esistente (es. ID 1, utente \"mario\") con\nun nuovo videogioco (es. \"Minecraft\"). Si aspetta che il metodo update completi l’operazione senza\nerrori e che il carrello aggiornato contenga il nuovo videogioco.\n• testFindByUtenteId Successo: Verifica il recupero di un carrello per l’ID di un utente (es. ID 1, \"mario\").\nSi aspetta che il metodo findByUtenteId restituisca un oggetto Carrello non nullo contenente\nvideogiochi attesi (es. ID 2).\n• testFindByUtenteId Fallimento UtenteNonEsistente: Testa il recupero di un carrello per un utente inesi-\nstente (es. ID 999). Si aspetta che il metodo findByUtenteId restituisca null, garantendo la gestione\ndegli errori.\n• testDelete Successo: Verifica l’eliminazione di un carrello dal database (es. ID 1, utente \"mario\"). Si\naspetta che il metodo delete completi l’operazione senza errori e che il carrello non sia pi`u recuperabile\ntramite findByUtenteId.\nComportamento in caso di fallimento: Il test testFindByUtenteId Fallimento UtenteNonEsistente\nverifica la robustezza della piattaforma nel gestire il recupero di carrelli per utenti inesistenti, restituendo null in\nmodo appropriato. Questo controllo assicura che il CarrelloDAO gestisca correttamente l’assenza di dati senza\ngenerare errori.\n@Test\nvoid testSave_Successo_CarrelloEsistente() {\nCarrello carrello = new Carrello(1, 1);\nVideogioco minecraft = videogiocoDAO.findById(5);\ncarrello.addVideogioco(minecraft);\nassertDoesNotThrow(() -> carrelloDAO.save(carrello));\nCarrello saved = carrelloDAO.findByUtenteId(1);\nassertEquals(1, saved.getIdUtente());\nassertTrue(saved.getVideogiochi().stream().anyMatch(v -> v.getId() == 5));\nassertFalse(saved.getVideogiochi().stream().anyMatch(v -> v.getId() == 2));\n}\n@Test\nvoid testUpdate_Successo() {\nCarrello carrello = carrelloDAO.findByUtenteId(1);\ncarrello.addVideogioco(videogiocoDAO.findById(5));\nassertDoesNotThrow(() -> carrelloDAO.update(carrello));\nCarrello updated = carrelloDAO.findByUtenteId(1);\nassertTrue(updated.getVideogiochi().stream().anyMatch(v -> v.getId() == 5));\n}\n@Test\nvoid testFindByUtenteId_Successo() {\nCarrello carrello = carrelloDAO.findByUtenteId(1);\nassertNotNull(carrello);\nassertEquals(1, carrello.getIdUtente());\nassertTrue(carrello.getVideogiochi().stream().anyMatch(v -> v.getId() == 2));\n}\n@Test\nvoid testFindByUtenteId_Fallimento_UtenteNonEsistente() {\nCarrello carrello = carrelloDAO.findByUtenteId(999);\nassertNull(carrello);\n}\n@Test\nvoid testDelete_Successo() {\nCarrello carrello = carrelloDAO.findByUtenteId(1);\n38\n",
  "40": "Samuele Lattanzi\nIngegneria del Software\nassertDoesNotThrow(() -> carrelloDAO.delete(carrello.getId()));\nCarrello deleted = carrelloDAO.findByUtenteId(1);\nassertNull(deleted);\n}\nSnippet 37: Test di CarrelloDAO\n4.3.3\nLibreriaDAOTest\nI test in LibreriaDAOTest verificano il comportamento delle operazioni CRUD per l’entit`a Libreria, come\nil salvataggio, il recupero e l’aggiornamento delle librerie degli utenti nel database.\nI test implementati in LibreriaDAOTest coprono i seguenti scenari:\n• testSave Successo NuovaLibreria:\nVerifica il salvataggio di una nuova libreria per un utente (es.\n\"luigi\", ID 2) contenente un videogioco (es. \"FIFA 23\") con stato di installazione. Si aspetta che\nil metodo save completi l’operazione senza errori e che la libreria recuperata contenga il videogioco con lo\nstato corretto.\n• testFindByUtenteId Successo: Verifica il recupero di una libreria per l’ID di un utente (es.\nID 1,\n\"mario\"). Si aspetta che il metodo findByUtenteId restituisca un oggetto Libreria non nullo\ncontenente videogiochi attesi (es. \"Super Mario Odyssey\") con stato di installazione corretto.\n• testFindByUtenteId Fallimento UtenteNonEsistente: Testa il recupero di una libreria per un utente inesi-\nstente (es. ID 999). Si aspetta che il metodo findByUtenteId restituisca null, garantendo la gestione\ndegli errori.\n• testUpdate Successo: Verifica l’aggiornamento di una libreria esistente (es. ID 1, utente \"mario\") con un\nnuovo videogioco installato (es. \"Fortnite\"). Si aspetta che il metodo update completi l’operazione\nsenza errori e che la libreria aggiornata rifletta lo stato di installazione corretto.\n@Test\nvoid testSave_Successo_NuovaLibreria() {\nLibreria libreria = new Libreria(0, 2); // Luigi\nVideogioco fifa = videogiocoDAO.findById(4); // FIFA 23\nlibreria.addVideogioco(fifa);\nlibreria.setVideogiocoInstallato(fifa, true);\nassertDoesNotThrow(() -> libreriaDAO.save(libreria));\nLibreria saved = libreriaDAO.findByUtenteId(2);\nassertNotNull(saved);\nassertEquals(2, saved.getIdUtente());\nassertTrue(saved.getVideogiochiAcquistati().stream().anyMatch(v -> v.getId() ==\n4));\nassertTrue(saved.isVideogiocoInstallato(fifa));\n}\n@Test\nvoid testFindByUtenteId_Successo() {\nLibreria libreria = libreriaDAO.findByUtenteId(1); // Mario\nassertNotNull(libreria);\nassertEquals(1, libreria.getIdUtente());\nassertTrue(libreria.getVideogiochiAcquistati().stream().anyMatch(v -> v.getId()\n== 1));\nassertTrue(libreria.isVideogiocoInstallato(videogiocoDAO.findById(1)));\n}\n@Test\nvoid testFindByUtenteId_Fallimento_UtenteNonEsistente() {\nLibreria libreria = libreriaDAO.findByUtenteId(999);\nassertNull(libreria);\n}\n@Test\nvoid testUpdate_Successo() {\n39\n",
  "41": "Samuele Lattanzi\nIngegneria del Software\nLibreria libreria = libreriaDAO.findByUtenteId(1); // Mario\nVideogioco fortnite = videogiocoDAO.findById(3); // Fortnite\nlibreria.setVideogiocoInstallato(fortnite, true);\nassertDoesNotThrow(() -> libreriaDAO.update(libreria));\nLibreria updated = libreriaDAO.findByUtenteId(1);\nassertTrue(updated.isVideogiocoInstallato(fortnite));\n}\nSnippet 38: Test di LibreriaDAO\n40\n"
}