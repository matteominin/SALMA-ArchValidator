{
  "1": "Library Management Application\nElaborato di Ingegneria del Software\nDocente: Enrico Vicario\nStudenti: Luca Lascialfari, Marco Siani, Tommaso Puzzo\n",
  "2": "Contenuti\n1\nIntroduzione\n1\n1.1\nObiettivi del progetto . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1\n1.2\nTecnologie e architettura utilizzate\n. . . . . . . . . . . . . . . . . . .\n1\n2\nProgettazione\n2\n2.1\nAttori coinvolti e relativi casi d’uso . . . . . . . . . . . . . . . . . . .\n2\n2.2\nUse Case Template . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3\n2.2.1\nUse Case condivisi\n. . . . . . . . . . . . . . . . . . . . . . . .\n3\n2.2.2\nUtente . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n5\n2.2.3\nAmministratore . . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n2.3\nDiagramma delle classi . . . . . . . . . . . . . . . . . . . . . . . . . .\n10\n2.4\nAspetti rilevanti del progetto . . . . . . . . . . . . . . . . . . . . . . .\n14\n2.4.1\nModel View Controller . . . . . . . . . . . . . . . . . . . . . .\n14\n2.4.2\nSingleton\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14\n2.4.3\nDAO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n15\n2.5\nPage Navigation Diagram\n. . . . . . . . . . . . . . . . . . . . . . . .\n16\n2.6\nEntity Relationship Diagram . . . . . . . . . . . . . . . . . . . . . . .\n17\n3\nImplementazione delle classi\n18\n3.1\nDomainModel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n18\n3.1.1\nElement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19\n3.1.2\nBook . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19\n3.1.3\nDigitalMedia\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n19\n3.1.4\nPeriodic Publication\n. . . . . . . . . . . . . . . . . . . . . . .\n20\n3.1.5\nGenre\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n20\n3.1.6\nUser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n20\n3.2\nController . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n21\n3.2.1\nAddItemViewController\n. . . . . . . . . . . . . . . . . . . . .\n21\n3.2.2\nBaseViewController . . . . . . . . . . . . . . . . . . . . . . . .\n21\n3.2.3\nBorrowedItemsViewController . . . . . . . . . . . . . . . . . .\n23\n3.2.4\nElementCheckViewController\n. . . . . . . . . . . . . . . . . .\n23\n3.2.5\nElementDetailsViewController . . . . . . . . . . . . . . . . . .\n23\n3.2.6\nHomeViewController . . . . . . . . . . . . . . . . . . . . . . .\n24\n3.2.7\nLoginViewController . . . . . . . . . . . . . . . . . . . . . . .\n24\n3.2.8\nMenuBarViewController . . . . . . . . . . . . . . . . . . . . .\n24\n3.2.9\nSignupViewController\n. . . . . . . . . . . . . . . . . . . . . .\n24\n3.3\nOrm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n26\n3.3.1\nConnectionManager . . . . . . . . . . . . . . . . . . . . . . . .\n26\n3.3.2\nElementDAO\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n26\n3.3.3\nBookDAO . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n26\n3.3.4\nBorrowsDAO\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n27\n3.3.5\nDigitalMediaDAO . . . . . . . . . . . . . . . . . . . . . . . . .\n27\n3.3.6\nGenreDAO\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n27\n3.3.7\nPeriodicPublicationDAO . . . . . . . . . . . . . . . . . . . . .\n27\n3.3.8\nUserDAO\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n28\n",
  "3": "3.4\nService . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n28\n3.4.1\nLibraryAdminService . . . . . . . . . . . . . . . . . . . . . . .\n28\n3.4.2\nLibraryUserService . . . . . . . . . . . . . . . . . . . . . . . .\n28\n3.4.3\nMainService . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n28\n3.4.4\nUserService . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n28\n3.5\nView . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n29\n3.5.1\nSignUp-view . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n30\n3.5.2\nAddItem-view . . . . . . . . . . . . . . . . . . . . . . . . . . .\n30\n3.5.3\nElementDetails-view\n. . . . . . . . . . . . . . . . . . . . . . .\n31\n3.5.4\nLogin-view . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n31\n3.5.5\nHome-view\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n32\n3.5.6\nBorrowed-view\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n32\n3.6\nHelloApplication\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n33\n3.7\nStruttura del database . . . . . . . . . . . . . . . . . . . . . . . . . .\n33\n4\nTesting\n35\n4.1\nBookDAOTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n36\n4.2\nBorrowsDAOTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n36\n4.3\nConnectionManagerTest\n. . . . . . . . . . . . . . . . . . . . . . . . .\n37\n4.4\nDigitalMediaDAOTest\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n37\n4.5\nElementDAOTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n38\n4.6\nGenreDAOTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n39\n4.7\nPeriodicPublicationDAOTest . . . . . . . . . . . . . . . . . . . . . . .\n40\n4.8\nUserDAOTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n40\n4.9\nMainServiceTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n41\n4.10 UserServiceTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n41\n4.11 LibraryUserServiceTest . . . . . . . . . . . . . . . . . . . . . . . . . .\n41\n4.12 LibraryAdminServiceTest\n. . . . . . . . . . . . . . . . . . . . . . . .\n41\n4.13 Risultati Maven . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n42\n",
  "4": "Sezione 1: Introduzione\n1\nIntroduzione\n1.1\nObiettivi del progetto\nQuesto progetto implementa un sistema di gestione di una biblioteca che permette:\n• agli utenti di prendere in prestito e restituire libri, media digitali e periodici.\n• agli amministratori di aggiungere, modificare e rimuovere ognuno di questi\nelementi dal catalogo della biblioteca.\nPer elemento si intende un qualsiasi prodotto presente nel catalogo della biblioteca,\nindipendentemente dalla sua tipologia effettiva.\n1.2\nTecnologie e architettura utilizzate\nL’applicativo `e sviluppato in Java 23 utilizzando l’IDE IntelliJ della suite di Jet-\nBrains. Per garantire la persistenza dei dati, `e stato adottato un database da remoto\ngestito tramite PostgreSQL1. La connessione al database `e gestita attraverso le\nlibrerie JDBC. L’interfaccia grafica `e stata sviluppata utilizzando le librerie open-\nsource JavaFX v. 17.0.62, le quali permettono la creazione di applicazioni GUI\nin Java. Per la realizzazione delle pagine di navigazione `e stato impiegato Scene\nBuilder, che fornisce un’interfaccia grafica utile a tale scopo. I diagrammi di pro-\ngettazione, inclusi i diagrammi delle classi e quelli relativi ai casi d’uso, sono stati\ncreati tramite StarUML. Il processo di testing `e stato realizzato con l’utilizzo del\nframework JUnit 53, supportato dall’uso della libreria Mockito v. 5.7.04 per la\nsimulazione delle dipendenze e dall’adozione di Maven v. 4.0.05 per l’automazione\ndel processo di build.\nTra le architetture utilizzate abbiamo invece:\n• MVC: Struttura l’applicazione separando i dati o Model, l’interfaccia utente,\ndefinita anche come View, e la logica di controllo, implementata tramite i\nController.\n• Service Layer: Introduce un livello intermedio tra il Controller e il Database.\n• DAO: Fornisce un’interfaccia per l’accesso ai dati, incapsulando le query SQL\ne l’interazione con il database.\n1PostgreSQL\n2JavaFX\n3JUnit\n4Mockito\n5Maven\n1\n",
  "5": "Sezione 2: Progettazione\n2\nProgettazione\n2.1\nAttori coinvolti e relativi casi d’uso\nL’applicativo individua 2 diversi attori:\n• Amministratore,\n• Utente.\nUn ulteriore attore `e il sistema stesso, il quale per`o agisce solo in risposta alle azioni\ndegli altri.\nOgnuno degli attori `e caratterizzato da diverse funzionalit`a, alcune delle quali in\ncomune, come si pu`o notare nei seguenti diagrammi dei casi d’uso.\nFigure 1: Diagramma dei casi d’uso\n2\n",
  "6": "2.2\nUse Case Template\n2.2\nUse Case Template\n2.2.1\nUse Case condivisi\nIn questa sezione sono riportati gli Use Case relativi a molteplici attori.\nUse Case\n1. Login\nLevel\nFunction\nDescription\nUtente usa e-mail e password per fare il login\nActors\nUtente, Amministratore\nPre-conditions\nDisporre di un account\nEssere connessi al database\nPost-conditions\nUtente esegue l’accesso correttamente o viene segnalato errore al\nlogin\nNormal flow\n1. Utente inserisce e-mail e password\n2. Utente preme il tasto Login\n3. Login avviene con successo\nAlternative flows\n3A. Se identificativo non nel database, compare scritta ”E-mail non\npresente”\n3B. Se identificativo esiste ma password sbagliata, compare scritta\n”Password errata”\n3C. Se non c’`e connessione al database, compare scritta ”Impossi-\nbile connettersi con il database”\nTable 1: Use Case Login\nUse Case\n2. Visualizza dettagli elemento\nLevel\nFunction\nDescription\nUtente visualizza informazioni dettagliate di uno specifico elemento\nselezionato\nActors\nUtente, Amministratore\nPre-conditions\n1. Essere connessi al database\n2. Aver effettuato il login\nPost-conditions\nUtente visualizza informazioni dettagliate sull’elemento\nNormal flow\n1. Utente clicca su un elemento dalla pagina Home\n2. Le informazioni sull’elemento vengono fornite\nVariations\n1. Un Utente pu`o accedere ai dettagli di un elemento anchge dalla\npagina Prestiti\nAlternative flows\n1A. Se non c’`e connessione al database, compare la scritta ”Impos-\nsibile connettersi al database.”\nTable 2: Use Case Dettagli elemento\n3\n",
  "7": "2.2\nUse Case Template\nUse Case\n3. Logout\nLevel\nFunction\nDescription\nUtente effettua il logout\nActors\nUtente, Amministratore\nPre-conditions\nDisporre di un account\nAvere eseguito il login\nPost-conditions\nUtente viene disconnesso correttamente\nNormal flow\n1. Utente preme il tasto Logout\n2. Logout avviene con successo\nTable 3: Use Case Logout\nUse Case\n5. Ricerca nel catalogo\nLevel\nUser goal\nDescription\nUtente utilizza filtri per ottenere una lista di elementi con le carat-\nteristiche desiderate\nActors\nUtente, Amministratore\nPre-conditions\n1. Disporre di un account\n2. Essere connessi al database\nPost-conditions\nVengono mostrati uno o pi`u elementi cercati o viene segnalato errore\nal login\nNormal flow\n1. Utente inserisce parametri di ricerca\n2. Vengono visualizzati a schermo gli elementi che corrispondono\nai parametri inseriti\nTable 4: Use Case Ricerca nel catalogo\nUse Case\n6. Visualizza catalogo\nLevel\nFunction\nDescription\nUtente visualizza una tabella contenente gli elementi presenti nel\ncatalogo\nActors\nUtente, Amministratore\nPre-conditions\n1. Disporre di un account\n2. Essere connessi al database\n3. Aver effettuato il login\nPost-conditions\nUtente visualizza una serie di elementi\nNormal flow\n1. Utente accede e visualizza tutti gli elementi presenti nel catalogo\nTable 5: Use Case Visualizza catalogo\n4\n",
  "8": "2.2\nUse Case Template\n2.2.2\nUtente\nL’Utente `e l’attore che si connetter`a al sistema con lo scopo di visualizzare il catal-\nogo, prenotare uno o pi`u elementi e di restituirli. Qui di seguito saranno presentati\nsolo gli Use Case che prevedono l’Utente come unico attore:\nUse Case\n4. Signup\nLevel\nUser Goal\nDescription\nUtente crea un account personale\nActors\nUtente\nPre-conditions\n1. Disporre di una e-mail\n2. Essere connessi al database\nPost-conditions\nUtente crea un account correttamente o viene segnalato errore al\nsignup\nNormal flow\n1. Utente inserisce e-mail, password, nome e cognome\n2. Utente preme il tasto Signup\n3. Signup avviene con successo\nVariations\n1. Utente pu`o inserire anche un numero di telefono\nAlternative flows\n3A. Se il testo inserito nel campo e-mail non corrisponde a un ind-\nirizzo e-mail possibile, compare scritta ”E-mail non valida”\n3B. Se la password contiene meno di 8 caratteri o non ha almeno una\nlettera minuscola, una maiuscola, una cifra e un carattere speciale\n(!, #, $, %, &, =, ?, @), compare la scritta ”Password non valida”\n3C. Se il nome non `e stato inserito, compare la scritta ”Nome non\ninserito”\n3D. Se il cognome non `e stato inserito, compare la scritta ”Cognome\nnon inserito”\n3E. Se `e stato inserito un numero di telefono non valido, compare\nla scritta ”Numero di telefono non valido”\n3F. Se e-mail nel database, compare scritta ”E-mail gi`a in uso”\n3G. Se non c’`e connessione al database, compare scritta ”Impossi-\nbile connettersi al database.”\nTable 6: Use Case Signup\n5\n",
  "9": "2.2\nUse Case Template\nUse Case\n7. Richiesta di un elemento in prestito\nLevel\nUser Goal\nDescription\nUtente prende un elemento in prestito\nActors\nUtente\nPre-conditions\n1. Disporre di un account\n2. Essere connessi al database\n3. Aver effettuato il login\nPost-conditions\nL’elemento viene dato in prestito all’Utente o viene seg-\nnalato un errore\nNormal flow\n1. Utente visualizza un elemento\n2. Utente preme il tasto per il prestito\n3. Utente riceve l’elemento in prestito\nAlternative flows\n3A. Se l’elemento `e gi`a stato preso in prestito dall’Utente,\ncompare la scritta ”Elemento gi`a preso in prestito”\n3B. Se l’elemento non `e disponibile, compare la scritta ”El-\nemento gi`a preso in prestito”\n3C. Se non c’`e connessione al database, compare la scritta\n”Impossibile connettersi al database.”\nTable 7: Use Case Richiesta di un elemento in prestito\nUse Case\n8. Restituzione di un elemento preso in prestito\nLevel\nUser goal\nDescription\nUtente restituisce uno o pi`u elementi che ha preso in prestito\nActors\nUtente\nPre-conditions\nDisporre di un account\nEssere connessi al database\nAver preso in prestito almeno un elemento\nPost-conditions\nElemento viene reso nuovamente disponibile per il prestito\no viene segnalato errore\nNormal flow\n1.\nUtente visualizza i dettagli di un elemento preso in\nprestito\n2. Utente preme il tasto ”Restituisci”\n3. L’elemento viene restituito correttamente\nAlternative flows\n3A. Se l’elemento selezionato non `e stato preso in prestito\ndall’Utente, compare la scritta ”Elemento non preso in\nprestito.”\n3B. Se non c’`e connessione al database, compare scritta\n”Impossibile connettersi al database.”\nTable 8: Use Case Restituzione di un elemento preso in prestito\n6\n",
  "10": "2.2\nUse Case Template\nUse Case\n9. Visualizza elementi presi in prestito\nLevel\nUser Goal\nDescription\nVisualizzazione degli elementi attualmente presi in prestito\nActors\nUtente\nPre-conditions\n1. Essere connessi al database\n2. Avere un account\n3. Aver effettuato il login\nNormal flow\n1. Utente clicca su apposito menu\n2. Viene visualizzata una lista con gli elementi attualmente presi\nin prestito dall’utente\nAlternative flows\n1A. Se non c’`e attualmente alcun prestito per l’Utente, compare la\nscritta ”Nessun elemento preso in prestito.”\n1A. Se non c’`e connessione al database, compare la scritta ”Impos-\nsibile connettersi al database.”\nTable 9: Use Case Visualizza elementi presi in prestito\n2.2.3\nAmministratore\nL’amministratore `e quell’attore che si occupa di gestire il sistema e il suo database.\nTra i suoi compiti troviamo quelli di aggiungere, rimuovere e modificare i vari ele-\nmenti e anche quello di aggiungere o rimuovere account amministratori.\nQui saranno presentati tutti gli Use Case che prevedono l’amministratore come\nunico attore in gioco:\nUse Case\n11. Rimuovere elemento\nLevel\nUser goal\nDescription\nAmministratore elimina un elemento dal database\nActors\nAmministratore\nPre-conditions\nAvere effettuato il login\nEssere connessi al database\nIl database deve contenere almeno un elemento\nPost-conditions\nElemento viene eliminato dal database o viene segnalato un\nerrore\nNormal flow\n1. Amministratore visualizza i dettagli dell’elemento che\nintende eliminare\n2. Amministratore preme il tasto ”Rimuovi”\n3. La rimozione dell’elemento avviene con successo\nAlternative flows\n3A. Se l’elemento `e al momento in prestito, compare\nla scritta ”Impossibile rimuovere un elemento ancora in\nprestito.”\n3B. Se non c’`e connessione al database, compare scritta\n”Impossibile connettersi al database.”\nTable 10: Use Case Rimuovere elemento\n7\n",
  "11": "2.2\nUse Case Template\nUse Case\n10. Aggiungere elemento al database\nLevel\nUser goal\nDescription\nAmministratore aggiunge un elemento nel database\nActors\nAmministratore\nPre-conditions\nAvere effettuato il login\nEssere connessi al database\nPost-conditions\nElemento viene aggiunto nel database correttamente o viene\nsegnalato un errore\nNormal flow\n1. Amministratore clicca sul bottone ”Aggiungi elemento”\n2. Amministratore compila il form con le informazioni nec-\nessarie\n3. Amministratore clicca su ”Save”\n4. L’elemento viene aggiunto al database\nAlternative flows\n3A. Se l’Amministratore clicca su ”Cancel”, viene annullata\nl’operazione\n4A. Se i campi del form non sono stati compilati corretta-\nmente, compare la scritta ”Informazioni insufficienti o non\nvalide.”\n4B. Se l’elemento che deve essere inserito `e un libro ed esiste\ngi`a nel catalogo un libro con lo stesso codice ISBN, compare\nla scritta ”ISBN gi`a presente nel database.”\n4C. Se non c’`e connessione al database, compare scritta\n”Impossibile connettersi al database.”\nTable 11: Use Case Aggiungere elemento al database\nUse Case\n13. Aggiunta di un genere\nLevel\nUser Goal\nDescription\nL’amministratore della biblioteca pu`o aggiungere uno o\npi`u generi al database.\nActors\nAmministratore\nPre conditions\nIl sistema `e connesso al database.\nIl amministratore ha effettuato l’accesso.\nNormal Flows\n1.L’amministratore seleziona l’opzione per aggiungere\nun nuovo genere.\n2. L’amministratore inserisce i nomi dei generi.\n3. I generi vengono salvati correttamente nel database,\no viene segnalato errore.\nAlternative Flows\n3A.Se un genere con quel nome `e gi`a presente, non viene\naggiunto e compare la scritta di errore ”Genere gi`a pre-\nsente nel database”.\n3B. Se non c’`e connessione al database, compare scritta\n”Impossibile connettersi al database”.\nTable 12: Caso d’Uso 13: Aggiunta di un genere\n8\n",
  "12": "2.2\nUse Case Template\nUse Case\n12. Modifica un elemento nel database\nLevel\nUser goal\nDescription\nAmministratore modifica un elemento selezionato\nActors\nAmministratore\nPre-conditions\nAvere effettuato il login\nEssere connessi al database\nIl database deve contenere almeno un elemento\nPost-conditions\nAmministratore modifica correttamente l’elemento o viene\nsegnalato un errore\nNormal flow\n1. Amministratore visualizza i dettagli dell’elemento che\nintende modificare\n2. Amministratore clicca su ”Modifica”\n3. Pagina della modifica viene caricata\n4. L’Amministratore effettua le modifiche necessarie\n5. Viene premuto il tasto ”Save”\n6. Le modifiche vengono aggiunte al database\nAlternative flows\n5A. Se l’Amministratore clicca su ”Cancel”, viene annullata\nl’operazione\n6A. Se i campi del form non sono stati compilati corretta-\nmente, compare la scritta ”Informazioni insufficienti o non\nvalide.”\n6B. Se viene modificato l’ISBN di un libro ed esiste gi`a nel\ncatalogo un libro con lo stesso codice ISBN, compare la\nscritta ”ISBN gi`a presente nel database.”\n6C. Se non c’`e connessione al database, compare scritta\n”Impossibile connettersi al database.”\nTable 13: Use Case Modifica un elemento nel database\n9\n",
  "13": "2.3\nDiagramma delle classi\n2.3\nDiagramma delle classi\nIl diagramma delle classi `e il seguente:\nFigure 2: Diagramma delle classi\n10\n",
  "14": "2.3\nDiagramma delle classi\nEntrando pi`u nel dettaglio i diagrammi UML delle singole componenti sono:\nFigure 3: Nel diagramma UML del Domain Model possiamo trovare le classi: User,\nElement, Genre e classi come PeriodicPublication, DigitalMedia e Book che esten-\ndono Element\n.\n11\n",
  "15": "2.3\nDiagramma delle classi\nFigure 4: Nel diagramma UML del controller invece possiamo trovare le classi:\nMenuBarViewController,\nBorrowedItemsController,\nSignupController,\nDescrip-\ntionElementController, LoginController, ElementCheckViewController che eredi-\ntano tutte dalla classe BaseViewController. Poi ci possiamo trovare BaseView-\nController, MainViewController e HomeController e AddItemController che eredi-\ntano da ElementCheckViewController\n.\nFigure 5: Nel Diagramma UML di ORM, possiamo vedere tutte le classi che si in-\nterfacciano con il database. Queste classi sono: BorrowsDAO, PeriodicPublication-\nDAO, GenreDAO, UserDAO, ElementDAO, DigitalMediaDAO, ConnectionMenager\ne BookDAO\n12\n",
  "16": "2.3\nDiagramma delle classi\nFigure 6: Nel diagramma UML di service, invece ci troviamo: MainService, UserSer-\nvice, LibraryUserService e LibraryAdminService. LibraryUserService e LibraryAd-\nminService estendono UserService\n.\n13\n",
  "17": "2.4\nAspetti rilevanti del progetto\n2.4\nAspetti rilevanti del progetto\nNella progettazione di questo applicativo sono stati utilizzati alcuni Design Pat-\ntern.\n2.4.1\nModel View Controller\nIl Model View Controller `e un pattern in grado di separare la logica di presentazione\ndei dati dalla logica di business.\nFigure 7: Diagramma UML del pattern MVC adattato al progetto\nNell’applicativo la parte del Model `e rappresentata dall’insieme dei package Do-\nmainModel e DAO, con l’aggiunta del database stesso.\nIl Controller `e composto dai package Service e Controller.\nInfine la View `e costituita dall’insieme dei vari file in formato fxml.\n2.4.2\nSingleton\nNella gestione della connessione al database e nel mantenimento dello stato del pro-\ngramma `e stato implementato il pattern Singleton. Questo garantisce l’esistenza di\nun unico ConnectionManager responsabile di gestire la connessione al database,\ne di un solo MainController, responsabile invece del mantenimento dello stato del\nsistema.\n14\n",
  "18": "2.4\nAspetti rilevanti del progetto\n2.4.3\nDAO\nIl DAO, o Data Access Object, `e un pattern utilizzato per separare la logica di\naccesso ai dati da quella di business in un’applicazione. Permette di isolare le op-\nerazioni di lettura e scrittura dei dati su un database da parte dell’applicazione che\ngestisce la logica aziendale.\nIl pattern offre un’interfaccia che definisce le operazioni di base come creare, leggere,\naggiornare ed eliminare, ovvero le operazioni CRUD sui dati.\nFigure 8: DAO\n15\n",
  "19": "2.5\nPage Navigation Diagram\n2.5\nPage Navigation Diagram\nL’interazione prevista che l’utente deve avere con l’interfaccia `e la seguente:\nFigure 9: Diagramma di Navigazione\n16\n",
  "20": "2.6\nEntity Relationship Diagram\n2.6\nEntity Relationship Diagram\nQui di seguito `e presentato il diagramma ER:\nFigure 10: Diagramma ER\n17\n",
  "21": "Sezione 3: Implementazione delle classi\n3\nImplementazione delle classi\nIl codice sorgente `e articolato nel modo seguente:\nFigure 11: Stuttura del codice sorgente\n3.1\nDomainModel\nIl DomainModel `e il package che si occupa di definire un modello di composizione\ndi classi su cui `e possibile eseguire i casi d’uso espressi nello Use Case Diagram.\nQuesto package si articola nelle seguenti classi, che descrivono le entit`a del do-\nminio dell’applicazione:\n18\n",
  "22": "3.1\nDomainModel\n3.1.1\nElement\nQuesta classe si occupa di fornire attributi e metodi comuni tra i vari elementi\npresenti all’interno del sistema. Gli elementi condivisi tra le varie classi sono:\n1. id\n2. title\n3. releaseYear\n4. description\n5. quantity\n6. quantityAvailable\n7. lenght\n8. genres\n3.1.2\nBook\nQuesta classe mantiene i dati riguardanti i libri presenti all’interno del catalogo\ndella biblioteca.\nTra questi dati, oltre a quelli ereditati dalla classe Element abbiamo:\n• isbn\n• author\n• publisher\n• edition\n3.1.3\nDigitalMedia\nQuesta classe si occupa di mentenere le informazioni relative ai media digitali\npresenti all’interno della biblioteca.\nTra questi dati, oltre a quelli ereditati dalla classe Element abbiamo:\n• producer\n• ageRating\n• director\n19\n",
  "23": "3.1\nDomainModel\n3.1.4\nPeriodic Publication\nQuesta classe `e stata progettata per mantenere le informazioni relative alle pubbli-\ncazioni di riviste o altri elementi periodici. Oltre alle informazioni ereditate dalla\nclasse Element, al suo interno troviamo:\n• publisher\n• frequency\n• releaseMonth\n• releaseDay\n3.1.5\nGenre\nQuesta classe viene utilizzata per mantenere informazioni sui vari generi che carat-\nterizzano un elemento.\nAl suo interno troviamo gli attributi name e code\n3.1.6\nUser\nQuesta classe si occupa di mantenere le informazioni relative agli utenti all’interno\ndel sistema. Tra queste informazioni `e presente un attributo Boolean utilizzato per\nidentificare se un utente `e Amministratore, o se non lo `e.\nAl suo interno troviamo:\n• email\n• password\n• name\n• surname\n• phone\n• isAdmin\nL’email `e utilizzata per effettuare le operazioni di login e signup, oltre ad essere\nl’identificativo di un user.\n20\n",
  "24": "3.2\nController\n3.2\nController\nIn questo package si trovano tutte le classi che si occupano di fornire i servizi\nrichiesti da un utente tramite la GUI.\n3.2.1\nAddItemViewController\nQuesta classe `e il controller di una vista che si occupa di gestire l’interfaccia grafica\nper aggiungere un item, che pu`o essere un libro, una rivista periodica o un media\ndigitale all’interno del sistema della libreria. Questa classe estende la classe El-\nementCheckViewController e permette di fare questa operazione in maniera\ncorretta tramite controlli di validit`a e permettendo di selezionare anche il tipo di\nitem che stiamo inserendo, in modo tale da richiedere per ognuno di questi ultimi,\nsolo le informazioni che lo riguardano.\n3.2.2\nBaseViewController\nQuesta classe `e un controller che viene utilizzato per offrire metodi comuni a tutti\ni controller e permette inoltre di tornare alla vista precedente tramite attributo\nlastView. Molti controller estendono questa classe e fanno l’overloading dei suoi\nmetodi.\n21\n",
  "25": "3.2\nController\nFigure 12: Classe BaseViewController\n22\n",
  "26": "3.2\nController\n3.2.3\nBorrowedItemsViewController\nQuesta classe `e un controller che gestisce la visualizzazione degli elementi presi in\nprestito da un utente della biblioteca.\nQuesta classe estende BaseViewController e interagisce con MainService e Li-\nbraryUserService per recuperare i dati degli elementi presi in prestito.\nFigure 13: Metodo initialize() di BorrowedItemsController\n3.2.4\nElementCheckViewController\nQuesto controller serve a gestire la validazione dell’inout nei campi di testo.\nEstende BaseViewController e contiene dei metodi per formattare correttamente\nil testo inserito dall’utente prima che esso venga accettato nel campo selezionato.\nOgnuna di queste operazioni viene fatta sulla base di alcuni filtri stabiliti durante\nla progettazione, atti ad accettare o meno il testo.\n3.2.5\nElementDetailsViewController\nQuesta classe controller serve per la visualizzazione dei dettagli di uno degli elementi\nselezionato, presenti all’interno del catalogo della biblioteca.\n23\n",
  "27": "3.2\nController\n3.2.6\nHomeViewController\nQuesta classe controller gestisce la schermata principale dell’applicazione, mostrando\nil catalogo degli elementi, presenti all’interno del sistema, utilizzando una tabella.\nInoltre questa classe fornisce anche la scelta di filtri, utili a ricercare un determinato\nelemento, o magari utili a cercare elementi simili a quelli gi`a presi in prestito in\npassato.\n3.2.7\nLoginViewController\nQuesta classe controller gestisce la schermata di login dell’applicativo e permette\nquindi l’autenticazione e l’accesso, di un utente, al sistema.\nEstende il controller BaseViewController, per esempio per mostrare messaggi di\nerrore che possono avvenire nell’autenticazione.\n3.2.8\nMenuBarViewController\nQuesta classe controller gestisce la barra dei menu dell’applicazione. A seconda del\ntipo di utente loggato, quindi utente normale o amministratore, questo controller\nmostra pi`u o meno opzioni. Un altro suo compito `e quello di gestire le azioni associate\nai menu, come la navigazione tra le viste, la gestione dei generi e il logout.\n3.2.9\nSignupViewController\nQuesta classe controller si occupa di gestire la schermata di registrazione del sis-\ntema, permettendo la creazione di un nuovo utente, validandone gli input inseriti e\nfacendolo accedere in automatico, nel caso in cui l’operazione andasse a buon fine.\n24\n",
  "28": "3.2\nController\nFigure 14: Metodo initialize() di MenuBarViewController\n25\n",
  "29": "3.3\nOrm\n3.3\nOrm\nQuesto package si occupa di gestire le comunicazioni con il database sia in lettura\nche in scrittura.\n3.3.1\nConnectionManager\nLa classe si occupa della gestione della connessione al database PostgreSQL per\nl’applicazione e garantisce che essa sia unica attraverso il design pattern single-\nton.\nLa classe contiene: La classe fornisce quindi un’interfaccia sicura e centralizzata\nMetodo\nDescrizione\ngetInstance()\nRestituisce l’unica istanza della classe, in quanto Single-\nton.\ngetConnection()\nRestituisce una connessione attiva al database, crean-\ndola se necessario.\nsetDbUser(String dbUser)\nImposta dinamicamente il nome utente del database.\nsetDbPass(String dbPass)\nImposta dinamicamente la password del database.\nisConnectionValid()\nVerifica se la connessione al database `e ancora valida.\ncloseConnection()\nChiude la connessione al database se `e attiva.\nTable 14: Metodi principali della classe ConnectionManager\nper la gestione della connessione al database, seguendo il pattern Singleton e im-\nplementando metodi per configurare, verificare e chiudere la connessione in modo\nefficiente.\n3.3.2\nElementDAO\nQuesta classe si occupa di fornire tutti i metodi necessari per la gestione di un\nelemento all’interno del sistema. Tali metodi si occupano, oltre che degli elementi\nstessi, anche dei dati complessi associati all’elemento su cui si opera, come ad esempio\nl’associazione di un genere ad un nuovo elemento.\nDa essa ereditano le classi:\n• BookManager\n• DigitalMediaManager\n• PeriodicPublicationManager\n3.3.3\nBookDAO\nLa classe BookManager gestisce le operazioni relative ai libri nel database, esten-\ndendo ElementManager. Si occupa di aggiungere, aggiornare, recuperare ed ef-\nfettuare ricerche sui libri.\n26\n",
  "30": "3.3\nOrm\n3.3.4\nBorrowsDAO\nLa classe BorrowsManager gestisce i prestiti di elementi nella biblioteca, interagendo\ncon la tabella borrows del database dalla quale possiamo ricavare informazioni che\ncollegano i vari utenti agli elementi che questi hanno preso in prestito.\n3.3.5\nDigitalMediaDAO\nQuesta classe si occupa della gestione di oggetti di tipo DigitalMedia. Essa es-\ntende la classe ElementManager e interagisce con il database tramite query SQL\nper eseguire operazioni di inserimento, aggiornamento, recupero e filtraggio di me-\ndia digitali.\n3.3.6\nGenreDAO\nQuesta classe fornisce metodi per aggiungere, rimuovere e recuperare i generi e\nper associare generi agli elementi nel sistema. Utilizza il ConnectionManager per\nottenere le connessioni al database e le query SQL per manipolare i dati.\nTra i suoi metodi notiamo, oltre ai metodi di aggiunta e rimozione dal database:\nMetodo\nDescrizione\ngetAllGenres()\nRecupera tutti i generi dal database. La query SELECT\neseguita senza filtri restituir`a tutti i generi presenti nella\ntabella genres.\nassociateGenreWithElement(Integer elementId, Integer genreCode) Associa\nun\ngenere\na\nun\nelemento.\nLa\nquery\nINSERT inserisce una riga nella tabella di associazione\nelementgenres utilizzando l’ID dell’elemento e il codice\ndel genere. Restituisce true se l’associazione ha successo.\nViene invocato dai metodi addElement e updateElement\ndi ElementDAO.\ngetGenresForElement(Integer elementId)\nRecupera tutti i generi associati a un elemento. La query\nSELECT unisce le tabelle genres ed elementgenres per\nottenere i generi per l’elemento specificato.\nremoveGenreFromElement(Integer elementId, Integer genreCode)\nRimuove l’associazione tra un elemento e un genere. La\nquery DELETE elimina la riga corrispondente nella tabella\nelementgenres, che collega l’elemento al genere. Resti-\ntuisce true se l’operazione ha successo. Viene invocato\ndai metodi updateElement e removeElement di Ele-\nmentDAO.\nTable 15: Metodi della classe GenreManager e descrizione\n3.3.7\nPeriodicPublicationDAO\nLa classe PeriodicPublicationManager `e una sottoclasse di ElementManager ed `e\nresponsabile della gestione delle pubblicazioni periodiche.\n27\n",
  "31": "3.4\nService\n3.3.8\nUserDAO\nQuesta classe si occupa della gestione degli utenti all’interno del database e offre la\npossibilit`a di: creare, aggiungere, rimuovere e aggiornare gli utenti.\nInoltre, questa classe si occupa anche di controllare l’unicit`a degli attributi utili\nall’identificazione dell’utente, insieme a un controllo che permetta di vedere se\nl’attributo inserito esiste o meno all’interno del sistema.\n3.4\nService\nIn un progetto i service permettono di separare la logica di buisness e la gestione\ndei dati dai controller che si occupano dell’interfaccia grafica. Sono classi riutiliz-\nzabili, ovvero possono essere usate da pi`u controller senza duplicare il codice.\nComunicano con database e altre risorse.\n3.4.1\nLibraryAdminService\nQuesta classe service estende UserService e si occupa di gestire le operazioni am-\nministrative dell’applicativo, come ad esempio l’aggiunta, la rimozione e l’aggiornamento\ndi elementi all’interno della biblioteca.\nUtilizza i DAO per interagire con il database e controlla prima la correttezza dei\ndati prima di eseguire operazioni, gestendo anche errori ed eccezioni.\n3.4.2\nLibraryUserService\nQuesto service estende UserService e si occupa di gestire le operazioni che possono\nessere effettuate da un utente normale della biblioteca, come la richiesta di prestito\ne la restituzione.\n3.4.3\nMainService\nQuesto service `e alla base dell’applicazione. In questa classe viene implementato il\ndesign pattern Singleton e comunicare con il DAO.\nIl suo compito `e quello di:\n1. Gestire l’accesso ai dati\n2. Tenere traccia dello stato dell’utente\n3. Fornisce i servizi per il resto dell’applicativo\n3.4.4\nUserService\nQuesto `e il service principale per la gestione degli utenti.\nSi occupa di gestire l’autenticazione, la registrazione e il logout al sistema. Inoltre\npermette di cercare,filtrare e visualizzare gli elementi nel sistema.\n28\n",
  "32": "3.5\nView\n3.5\nView\nNel progetto sono presenti varie viste, realizzate utilizzando JavaFX che, grazie\nall’applicazione SceneBuilder, consente di realizzare interfacce in modo rapido e\nsemplice. Di seguito verranno mostrate e brevemente spiegate alcune viste:\nFigure 15: Viste dell’applicativo\n29\n",
  "33": "3.5\nView\n3.5.1\nSignUp-view\nFigure 16: Screenshot della pagina di Signup\n3.5.2\nAddItem-view\nFigure 17: Screenshot della pagina usata per aggiungere nuovi elementi al catalogo,\nvisibile solo agli Amministratori. Questa pagina viene anche utilizzata per la mod-\nifica degli elementi\n30\n",
  "34": "3.5\nView\n3.5.3\nElementDetails-view\nFigure 18: Screenshot della pagina che mostra i dettagli dell’elemento selezionato\n3.5.4\nLogin-view\nFigure 19: Screenshot della pagina di Login\n31\n",
  "35": "3.5\nView\n3.5.5\nHome-view\nFigure 20: Screenshot della pagina Home\n3.5.6\nBorrowed-view\nFigure 21: Screenshot della pagina dei Prestiti, visibile solo ad un Utente\n.\n32\n",
  "36": "3.6\nHelloApplication\n3.6\nHelloApplication\nQuesta `e la classe Main del sistema. Si tratta di una classe derivata di Application,\nil cui scopo `e quello di gestire la configurazione della finestra e il caricamento della\nvista iniziale, oltre che a inizializzare i vari singleton.\nLa funzione main si occupa di avviare il programma.\n3.7\nStruttura del database\nPer la gestione dei dati sia degli utenti, degli elementi, delle prese in prestito e delle\nrestituzioni si utilizza un database relazionale gestito attraverso PostgreSQL. In\nfigura si mostra la struttura del database.\nCREATE TABLE users (\nemail VARCHAR PRIMARY KEY,\npassword VARCHAR,\nname VARCHAR,\nsurname VARCHAR,\nphone VARCHAR,\nisadmin BOOLEAN\n);\nCREATE TABLE elements (\nid SERIAL PRIMARY KEY,\ntitle VARCHAR,\nreleaseyear INT,\ndescription TEXT,\nquantity INT,\nquantityavailable INT,\nlength INT\n);\nCREATE TABLE books (\nid INT PRIMARY KEY,\nisbn VARCHAR,\nauthor VARCHAR,\npublisher VARCHAR,\nedition VARCHAR,\nFOREIGN KEY (id) REFERENCES elements(id)\n);\n33\n",
  "37": "3.7\nStruttura del database\nCREATE TABLE digitalmedias (\nid INT PRIMARY KEY,\nproducer VARCHAR,\nagerating VARCHAR,\ndirector VARCHAR,\nFOREIGN KEY (id) REFERENCES elements(id)\n);\nCREATE TABLE periodicpublication (\nid INT PRIMARY KEY,\npublisher VARCHAR,\nfrequency VARCHAR,\nreleasemonth INT,\nreleaseday INT,\nFOREIGN KEY (id) REFERENCES elements(id)\n);\nCREATE TABLE borrows (\nelementid INT,\nuserid VARCHAR,\nPRIMARY KEY (elementid, userid),\nFOREIGN KEY (elementid) REFERENCES elements(id),\nFOREIGN KEY (userid) REFERENCES users(email)\n);\nCREATE TABLE genres (\ncode VARCHAR PRIMARY KEY,\nname VARCHAR\n);\nCREATE TABLE elementgenres (\nelementid INT,\ngenrecodes VARCHAR,\nPRIMARY KEY (elementid, genrecodes),\nFOREIGN KEY (elementid) REFERENCES elements(id),\nFOREIGN KEY (genrecodes) REFERENCES genres(code)\n);\nFigure 22: Struttura del database\n34\n",
  "38": "Sezione 4: Testing\n4\nTesting\nIn questa sezione verranno elencati i test che sono stati effettuati. Per fare i test\nsono stati utilizzati Maven, JUnit5 e Mockito-JUnit.\nI test sono di tipo strutturale e sono atti a verificare la corretta interazione con il\ndatabase e sul suo utilizzo.\nLa struttura dei test `e la seguente:\nFigure 23: Struttura dei test\n35\n",
  "39": "4.1\nBookDAOTest\n4.1\nBookDAOTest\nLa classe BookDAOTest `e una suite di test che verifica il corretto funzionamento\ndella classe BookDAO, che si occupa della gestione dei libri nel database. I test\nutilizzano Mocking con Mockito per simulare il comportamento delle dipendenze,\nevitando di interagire direttamente con il database in alcuni casi.\nNome Test\nScopo\nAspettativa\nPossibili\nFalli-\nmenti\naddBookTest\nVerifica\nl’inserimento\ndi\nun\nlibro\nnel\ndatabase\nDeve restituire un\nID\nvalido\ndopo\nl’inserimento\nIl libro non viene\naggiunto e l’ID `e\nnull\nupdateBookTest\nVerifica\nl’aggiornamento\ndi\nun\nlibro\nes-\nistente\nLa funzione deve\nrestituire true se\nl’aggiornamento\nha successo\nIl libro non viene\naggiornato corret-\ntamente\ngetBookByIsbnTest Verifica\nil\nrecu-\npero di un libro\ntramite ISBN\nIl\nlibro\ntrovato\ndeve\navere\nlo\nstesso\nISBN\nrichiesto\nNessun\nlibro\ntrovato\noppure\nISBN errato\nTable 16: Riepilogo dei test eseguiti su BookDAO.\nQuesta classe testa correttamente le operazioni CRUD sulla gestione dei libri,\nverificando che l’aggiunta, l’aggiornamento e il recupero funzionino come previsto. I\ntest utilizzano mocking per isolare il database e altre classi, garantendo che i risultati\nsiano affidabili senza dipendere da una connessione attiva al database.\n4.2\nBorrowsDAOTest\nQuesta classe di test BorrowsDAOTest verifica il corretto funzionamento della\nclasse BorrowsDAO, che gestisce il prestito di elementi.\nNome Test\nScopo\nAspettativa\nPossibili Fallimenti\naddBorrowTest\nVerifica\nl’aggiunta\ndi un prestito\nDeve restituire true\ndopo aver aggiunto il\nprestito\nIl prestito non viene\nregistrato e il metodo\nrestituisce false\nremoveBorrowTest\nVerifica\nla\nri-\nmozione\ndi\nun\nprestito\nDeve restituire true\ndopo aver rimosso il\nprestito\nIl prestito non viene\nrimosso dal database\ngetBorrowedElementsForUserTest\nVerifica il recupero\ndei prestiti per un\nutente\nDeve\nrestituire\nun\nelenco di prestiti non\nnull\nIl metodo restituisce\nnull,\nindicando\nun\nproblema\nTable 17: Tabella riassuntiva dei test su BorrowsDAO\nI test effettuati sulla classe BorrowsDAO hanno verificato le funzionalit`a principali\nrelative alla gestione dei prestiti. In particolare:\n36\n",
  "40": "4.3\nConnectionManagerTest\n• Aggiunta di un prestito:\nIl test addBorrowTest ha confermato che il\nmetodo registra correttamente un nuovo prestito nel database, restituendo\nun valore positivo in caso di successo.\n• Rimozione di un prestito: Il test removeBorrowTest ha dimostrato che\n`e possibile eliminare un prestito esistente, garantendo che l’elemento venga\neffettivamente rimosso dal sistema.\n• Recupero dei prestiti di un utente: Il test getBorrowedElementsForUserTest\nha garantito che l’applicazione `e in grado di restituire un elenco valido di ele-\nmenti attualmente presi in prestito da un utente specifico.\nI test hanno fornito risultati coerenti con le aspettative, garantendo che il sistema\ngestisca correttamente l’aggiunta, la rimozione e il recupero dei prestiti.\n4.3\nConnectionManagerTest\nQuesta classe, ConnectionManagerTest, gestisce la connessione a un database Post-\ngreSQL per i test.\n• Connessione al database: Il metodo getConnection() viene chiamato per\nassicurarsi che la connessione al database per i test venga creata correttamente.\n• Verifica della validit`a: isConnectionValid() garantisce che la connessione\nsia utilizzabile prima di procedere con altre operazioni.\n• Chiusura della connessione: closeConnection() assicura che la connes-\nsione venga chiusa correttamente dopo l’uso.\nPer questi test dobbiamo tenere di conto che:\n• Pattern Singleton: Usato per mantenere un’unica connessione.\n• Gestione delle eccezioni: Gli errori di connessione vengono catturati e stam-\npati.\n• Metodi setDbUser() e setDbPass(): Permettono di cambiare le credenziali.\n4.4\nDigitalMediaDAOTest\nQuesta classe testa le operazioni di gestione dei media digitali effettuati da Digi-\ntalMediaDAO, verificando che i metodi funzionino correttamente con il database.\nI test condotti sulla classe DigitalMediaDAO confermano il corretto funziona-\nmento delle operazioni principali sulla gestione dei media digitali. In particolare:\n• Il metodo di inserimento di un media digitale, addDigitalMediaTest, ha sem-\npre restituito un identificativo valido, dimostrando la corretta interazione con\nil database.\n• Il metodo di aggiornamento updateDigitalMediaTest ha sempre restituito\ntrue, segnalando che le modifiche ai dati vengono applicate correttamente.\n37\n",
  "41": "4.5\nElementDAOTest\nTest\nScopo\nCriterio di Successo\naddDigitalMediaTest()\nVerifica che un media digitale\npossa essere inserito nel database.\nIl metodo restituisce un\nID valido, non null.\nupdateDigitalMediaTest()\nControlla che i dati di un media\ndigitale possano essere aggiornati.\nIl\nmetodo\nrestituisce\ntrue.\ngetDigitalMediaTest()\nTesta il recupero di un media dig-\nitale dal database.\nIl metodo restituisce un\noggetto valido, non null.\nTable 18: Riassunto dei test effettuati sulla classe DigitalMediaDAO\n• Il metodo di recupero dei media digitali getDigitalMediaTest ha restituito\noggetti validi, confermando l’integrit`a dei dati salvati.\nL’uso di Mockito per il mocking del ConnectionManager e del MainService ha\npermesso di isolare il codice e testare le funzionalit`a senza dipendere da un database\nreale. Inoltre, grazie all’uso del rollback alla fine dei test, i dati temporanei non\nvengono mantenuti nel database.\n4.5\nElementDAOTest\nI test condotti nella classe ElementDAOTest si occupano di verificare il corretto\nfunzionamento di operazioni CRUD sugli elementi all’interno del database.\nPer\ntestare la rimozione di un elemento si opera nel seguente modo:\n• Preparazione: Viene inserito un elemento nel database con una query SQL.\nL’ID generato per l’elemento viene salvato per essere utilizzato nel test.\n• Test: Viene chiamato il metodo removeElement(generatedId) per rimuo-\nvere l’elemento dal database. Successivamente, viene effettuata l’asserzione\nassertTrue(removeElement(generatedId)), che verifica che la rimozione sia\nstata eseguita correttamente.\n• Verifica: Se il test passa, significa che l’elemento `e stato correttamente ri-\nmosso dal database.\nInvece per quanto riguarda il corretto recupero di un elemento:\n• Preparazione: Viene inserito un nuovo elemento nel database, e l’ID generato\nper l’elemento viene salvato per essere utilizzato nel test.\n• Test:\nViene chiamato il metodo getElement(generatedId) per recuper-\nare l’elemento dal database.\nSuccessivamente, viene effettuata l’asserzione\nassertEquals(generatedId, element.getId()), che verifica che l’ID dell’elemento\nrecuperato corrisponda all’ID generato precedentemente.\n• Verifica: Se l’asserzione passa, significa che il metodo getElement() funziona\ncorrettamente e recupera gli elementi dal database in modo corretto.\n38\n",
  "42": "4.6\nGenreDAOTest\nI test effettuati hanno consentito di verificare il corretto funzionamento delle\noperazioni di rimozione e recupero sugli ”elementi” nel database. In particolare, i\ntest hanno confermato che:\n• Il metodo removeElement() rimuove correttamente un elemento dal database.\n• Il metodo getElement() recupera correttamente un elemento dal database\nutilizzando l’ID.\n4.6\nGenreDAOTest\nI test nella classe GenreDAOTest sono progettati per verificare il corretto funziona-\nmento dei metodi relativi alla gestione dei generi associati agli elementi nel sistema.\nI test coprono vari scenari, tra cui l’associazione di generi agli elementi, l’aggiunta\ne la rimozione di generi, nonch´e il recupero dei generi per un dato elemento.\nTest di Setup e Teardown:\n• @BeforeAll e @AfterAll: Questi metodi vengono eseguiti prima e dopo tutti\ni test nella classe.\n• setUp(): Crea un elemento e un genere nel database, i cui ID e codici vengono\nsalvati per essere utilizzati nei test successivi.\n• tearDown(): Rimuove i dati inseriti nel database durante i test, cancellando\nle associazioni e i dati generati.\nNel dettaglio dei test:\nTest: associateGenreWithElementTest()\n• Scopo: Verificare che un genere possa essere correttamente associato a un\nelemento.\n• Preparazione: L’ID dell’elemento generatedElementId e il codice del genere\ngeneratedGenreCode sono gi`a presenti nel database.\n• Esecuzione: Viene chiamato il metodo associateGenreWithElement(generatedElementId,\ngeneratedGenreCode).\n• Verifica:\nL’asserzione assertTrue(result) verifica che l’associazione sia\nriuscita.\nTest: addGenreTest()\n• Scopo: Verificare che un nuovo genere possa essere aggiunto al database.\n• Preparazione: Non `e necessaria alcuna preparazione in quanto il test si con-\ncentra sull’aggiunta di un nuovo genere.\n• Esecuzione: Viene chiamato il metodo addGenre(new Genre(\"Insert Test\")).\n• Verifica: L’asserzione assertTrue(result) verifica che il genere sia stato\naggiunto correttamente.\n39\n",
  "43": "4.7\nPeriodicPublicationDAOTest\nTest: getAllGenresTest()\n• Scopo: Verificare che tutti i generi possano essere recuperati correttamente.\n• Preparazione: I generi esistenti sono gi`a nel database, incluso quello inserito\nnel test precedente.\n• Esecuzione: Viene chiamato il metodo getAllGenres() per recuperare tutti\ni generi.\n• Verifica: L’asserzione assertNotNull(result) verifica che la lista di generi\nnon sia vuota.\nTest: getGenresForElementTest()\n• Scopo: Verificare che i generi associati a un elemento possano essere recuperati\ncorrettamente.\n• Preparazione: Un’associazione tra l’elemento generatedElementId e il genere\ngeneratedGenreCode viene inserita nella tabella elementgenres.\n• Esecuzione: Viene chiamato il metodo getGenresForElement(generatedElementId).\n• Verifica: L’asserzione assertNotNull(result) verifica che la lista di generi\nassociati all’elemento non sia vuota.\nTest: removeGenreFromElementTest()\n• Scopo: Verificare che un genere possa essere rimosso da un elemento.\n• Preparazione: Un’associazione tra l’elemento generatedElementId e il genere\ngeneratedGenreCode viene inserita nella tabella elementgenres.\n• Esecuzione: Viene chiamato il metodo removeGenreFromElement(generatedElementId,\ngeneratedGenreCode).\n• Verifica: L’asserzione assertTrue(result) verifica che la rimozione sia rius-\ncita.\n4.7\nPeriodicPublicationDAOTest\nI test nella classePeriodicPublicationDAOTest sono stati progettati con lo scopo\ndi testare l’aggiunta di un elemento PeriodicPublication all’interno del database\ne di un suo eventuale aggiornamento.\n4.8\nUserDAOTest\nI test nella classe UserDAOTest sono stati progettati per verificare il corretto\nfunzionamento della classe UserDAO.\n40\n",
  "44": "4.9\nMainServiceTest\n4.9\nMainServiceTest\nI test della classe MainServiceTest sono stati progettati per verificare il corretto\nfunzionamento della classe MainService.\n4.10\nUserServiceTest\nI test della classe UserServiceTest sono stati progettati per verificare il corretto\nfunzionamento della classe UserService.\nQuesti test controllano la corretta implementazione degli Use Case 1, 4, 5 e 6,\nassicurando che vengano rispettati tutti i flussi alternativi.\n4.11\nLibraryUserServiceTest\nI test della classe LibraryUserServiceTest sono stati progettati per verificare il\ncorretto funzionamento della classe LibraryUserService.\nQuesti test controllano la corretta implementazione degli Use Case 7. 8 e 9, assicu-\nrando che vengano rispettati tutti i flussi alternativi.\n4.12\nLibraryAdminServiceTest\nI test della classe LibraryAdminServiceTest sono stati progettati per verificare\nil corretto funzionamento della classe LibraryAdminService.\nQuesti test controllano la corretta implementazione degli Use Case 10, 11, 12 e 13,\nassicurando che vengano rispettati tutti i flussi alternativi.\n41\n",
  "45": "4.13\nRisultati Maven\n4.13\nRisultati Maven\nI risultati ottenuti tramite i test effettuati con Maven sono i seguenti:\n42\n",
  "46": "4.13\nRisultati Maven\n43\n",
  "47": "4.13\nRisultati Maven\nFigure 24: Risultati dei test\n44\n"
}